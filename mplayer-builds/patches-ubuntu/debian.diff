Index: create_deb.sh
===================================================================
--- create_deb.sh	(revisión: 0)
+++ create_deb.sh	(revisión: 0)
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+svn_revision=`LC_ALL=C svn info 2> /dev/null | grep Revision | cut -d' ' -f2`
+test $svn_revision || svn_revision=`grep revision .svn/entries 2>/dev/null | cut -d '"' -f2`
+test $svn_revision || svn_revision=`sed -n -e '/^dir$/{n;p;q;}' .svn/entries 2>/dev/null`
+test $svn_revision || svn_revision=UNKNOWN
+
+# New debian
+mv debian debian-upstream
+ln -sf debian-rvm debian
+
+# Add entry to changelog with svn revision
+cp debian/changelog-orig debian/changelog
+dch -v "2:1.0~rc3svn$svn_revision" "New version"
+
+# Build
+rm build-gui-stamp
+chmod 755 debian-rvm/rules
+fakeroot debian/rules binary
+
+# Clean
+dh_clean
+rm debian/changelog
+rm debian
+mv debian-upstream debian

Cambios de propiedades en create_deb.sh
___________________________________________________________________
Nombre: svn:executable
   + *

Index: version.sh
===================================================================
--- version.sh	(revisión: 29638)
+++ version.sh	(copia de trabajo)
@@ -15,6 +15,8 @@
 version=$(cat VERSION 2> /dev/null)
 test $version || version=$svn_revision
 
+extra="-Ubuntu-RVM"
+
 NEW_REVISION="#define VERSION \"${version}${extra}\""
 OLD_REVISION=$(head -n 1 version.h 2> /dev/null)
 TITLE='#define MP_TITLE "%s "VERSION" (C) 2000-2009 MPlayer Team\n"'
Index: debian-rvm/control
===================================================================
--- debian-rvm/control	(revisión: 0)
+++ debian-rvm/control	(revisión: 0)
@@ -0,0 +1,51 @@
+Source: mplayer
+Section: graphics
+Priority: extra
+Maintainer: Ricardo Villalba <rvm@escomposlinux.org>
+Standards-Version: 3.7.2
+Build-Depends: debhelper (>= 5.0.37), dpatch, libschroedinger-dev, libdirac-dev (>= 1.0.2), nvidia-180-libvdpau-dev [i386 amd64] | libartsc0-dev | libdvdread4, libopencore-amrnb-dev, libopencore-amrwb-dev, yasm (>= 0.7.1), libncurses5-dev, libesd0-dev, liblircclient-dev, libgtk2.0-dev, libvorbis-dev, libsdl1.2-dev, sharutils, libasound2-dev (>= 1.0.1), liblzo2-dev, gawk, libjpeg62-dev, libaudiofile-dev, libsmbclient-dev, libxv-dev, libpng3-dev, libgif-dev, libcdparanoia0-dev, libxvidcore4-dev, libdv-dev, liblivemedia-dev (>= 2004.05.01), libfreetype6-dev, em8300-headers, libgl1-mesa-dev | libgl-dev, libdts-dev, libtheora-dev, libglu1-mesa-dev | libglu-dev, libfontconfig-dev, libxxf86dga-dev, libxinerama-dev, libxxf86vm-dev, libmp3lame-dev | liblame-dev, libxvmc-dev, libggi2-dev, libmpcdec-dev, libspeex-dev, libfribidi-dev, libfaac-dev (>=1.26), sed (>= 4.0), libaa1-dev, libcaca-dev, libx264-dev (>= 1:0.svn20081230), libpulse-dev, libmad0-dev, ladspa-sdk, libdbus-glib-1-dev, libaudio-dev, libopenal-dev, libjack-dev, libtwolame-dev, libsvga1-dev [i386 amd64], libenca-dev, docbook-xml, docbook-xsl, xsltproc, libxml2-utils
+XSBC-Original-Maintainer: Ubuntu MOTU Media Team <motumedia@tauware.de>
+
+Package: mplayer
+Architecture: any
+Pre-Depends: dpkg (>= 1.14.12ubuntu3)
+Depends: ${shlibs:Depends}, mplayer-skins, ttf-dejavu-core
+Suggests: w32codecs [i386], w64codecs [amd64], libdvdcss2, mplayer-doc, smplayer
+Conflicts: mplayer-nogui
+Replaces: mplayer-nogui
+Description: The Ultimate Movie Player For Linux
+ It plays most mpeg, avi and asf files, supported by many native and win32
+ DLL codecs. You can watch VCD, DVD and even DivX movies too. The other
+ big feature of mplayer is the wide range of supported output drivers. It
+ works with X11, Xv, DGA, OpenGL, SVGAlib, fbdev, but you can use SDL (and
+ this way all drivers of SDL) and some lowlevel card-specific drivers (for
+ Matrox/3dfx/SiS) too! Most of them supports software or hardware scaling,
+ so you can enjoy movies in fullscreen.
+ .
+ This version includes the Gtk GUI
+
+Package: mencoder
+Architecture: any
+Pre-Depends: dpkg (>= 1.14.12ubuntu3)
+Depends: ${shlibs:Depends}
+Suggests: w32codecs [i386], w64codecs [amd64], libdvdcss2, mplayer-doc
+Description: MPlayer's Movie Encoder
+ A simple movie encoder, designed to encode MPlayer-playable movies
+ (AVI/ASF/OGG/DVD/VCD/VOB/MPG/MOV/VIV/FLI/RM/NUV/NET) to other
+ MPlayer-playable formats. It can encode with various codecs, like DivX4 (1
+ or 2 passes), libavcodec, PCM/MP3/VBRMP3 audio. Also has stream copying and
+ video resizing abilities.
+
+Package: mplayer-doc
+Architecture: all
+Pre-Depends: dpkg (>= 1.14.12ubuntu3)
+Description: The Ultimate Movie Player For Linux (Documentation)
+ It plays most mpeg, avi and asf files, supported by many native and win32
+ DLL codecs. You can watch VCD, DVD and even DivX movies too. The other
+ big feature of mplayer is the wide range of supported output drivers. It
+ works with X11, Xv, DGA, OpenGL, SVGAlib, fbdev, but you can use SDL (and
+ this way all drivers of SDL) and some lowlevel card-specific drivers (for
+ Matrox/3dfx/SiS) too! Most of them supports software or hardware scaling,
+ so you can enjoy movies in fullscreen.
+ .
+ This package contains the documentation for mplayer/mencoder
Index: debian-rvm/compat
===================================================================
--- debian-rvm/compat	(revisión: 0)
+++ debian-rvm/compat	(revisión: 0)
@@ -0,0 +1 @@
+5
Index: debian-rvm/changelog-orig
===================================================================
--- debian-rvm/changelog-orig	(revisión: 0)
+++ debian-rvm/changelog-orig	(revisión: 0)
@@ -0,0 +1,507 @@
+mplayer (2:1.0~rc2-0ubuntu15) intrepid; urgency=low
+
+  * Modify etc/mplayer.desktop to make it validate with
+    desktop-file-validate (LP: #244720)
+
+ -- Nathan Handler <nathan.handler@gmail.com>  Wed, 03 Sep 2008 12:38:53 +0100
+
+mplayer (2:1.0~rc2-0ubuntu14) intrepid; urgency=low
+
+  * Rebuild for liblame -> libmp3lame transition and adjust build-deps
+    accordingly (LP: #262832)
+  * Disable IVTV vo and ao as this causes the package to fail to build 
+
+ -- Iain Lane <iain@orangesquash.org.uk>  Tue, 02 Sep 2008 08:12:10 +0100
+
+mplayer (2:1.0~rc2-0ubuntu13) hardy; urgency=low
+
+  * SECURITY UPDATE: arbitrary code execution via crafted RTSP stream.
+    (LP: #212601)
+    - stream/realrtsp/sdpplin.c: Properly check the stream ID. Patch from
+      upstream.
+    - References:
+      + CVE-2008-1558
+
+ -- William Grant <william@qeuni.net>  Sun, 06 Apr 2008 10:49:10 +1000
+
+mplayer (2:1.0~rc2-0ubuntu12) hardy; urgency=low
+
+  * Modify mplayer.desktop to support opening URIs with spaces (LP: #164709).
+
+ -- Matti Lindell <mlind@cs.joensuu.fi>  Tue, 25 Mar 2008 19:01:10 +0200
+
+mplayer (2:1.0~rc2-0ubuntu11) hardy; urgency=low
+
+  * Actually drop the runtime CPU detection configure flag from the
+    arch-global variable, which I apparently missed in bzr last time.
+
+ -- William Grant <william@qeuni.net>  Mon, 24 Mar 2008 21:29:34 +1100
+
+mplayer (2:1.0~rc2-0ubuntu10) hardy; urgency=low
+
+  * Only build-depend on libsvga1-dev on i386 and amd64; it doesn't exist
+    anywhere else.
+  * Only enable runtime CPU detection on i386, amd64 and powerpc. Fixes FTBFS
+    on [!i386 amd64 powerpc].
+
+ -- William Grant <william@qeuni.net>  Mon, 24 Mar 2008 20:32:46 +1100
+
+mplayer (2:1.0~rc2-0ubuntu9) hardy; urgency=low
+
+  [ Luke Yelavich ]
+  * etc/example.conf: Use pulseaudio by default, and fallback to alsa.
+
+  [ William Grant ]
+  * SECURITY UPDATE: buffer overruns in CDDB, MOV demuxer, FLAC header parser,
+    and URL parser. (LP: #191488)
+  * libmpdemux/demux_audio.c, libmpdemux/demux_mov.c, stream/stream_cddb.c,
+    stream/url.c: Patches from upstream.
+  * References:
+    - CVE-2008-0485
+    - CVE-2008-0486
+    - CVE-2008-0629
+    - CVE-2008-0630
+  * debian/rules: Unset CFLAGS, to make it build again.
+
+ -- William Grant <william@qeuni.net>  Mon, 24 Mar 2008 13:55:38 +1100
+
+mplayer (2:1.0~rc2-0ubuntu8) hardy; urgency=low
+
+  * Use DejaVu instead of Bitstream Vera for subtitles so they show
+    correct characters for many non-English languages (LP: #48497)
+
+ -- Jani Monoses <jani@ubuntu.com>  Wed, 06 Feb 2008 09:27:55 +0200
+
+mplayer (2:1.0~rc2-0ubuntu7) hardy; urgency=low
+
+  * Add debian/mime to install mime types in (g)mplayer.
+  * Rebuild against newer x264 (LP: 177082, 172683, 181389)
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Wed, 23 Jan 2008 01:24:45 -0600
+
+mplayer (2:1.0~rc2-0ubuntu6) hardy; urgency=low
+
+  * debian/rules:
+    - Drop old get-orig-source to avoid confusion.
+  * debian/control:
+    - Build depend on newer faac for libmp4v2 transition. (LP: 181389)
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Tue, 22 Jan 2008 13:41:16 -0600
+
+mplayer (2:1.0~rc2-0ubuntu5) hardy; urgency=low
+
+  * Rebuild against libgif-dev instead of linungif4-dev (LP: #174252)
+
+ -- Ilya Eremin <che_guevara_3@bk.ru>  Sat, 22 Dec 2007 01:32:53 +0000
+
+mplayer (2:1.0~rc2-0ubuntu4) hardy; urgency=low
+
+  [ Mario Limonciello ]
+  * Rebuild against newer x264. (LP: #173624, 174087)
+  * Build with enca support. (LP: #115519)
+  * Fix gnome_screensaver errors. (LP: #108785, 104660, 159909, 113818)
+
+  [ Luca Barbieri ]
+  * Add locking support to Pulse Audio to prevent deadlocks. (LP: #136850)
+
+  [ Phillip Belemezov ]
+  * Fix gnome screensaver on amd64 (LP: #104660, 159861)
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Tue, 11 Dec 2007 02:13:54 -0600
+
+mplayer (2:1.0~rc2-0ubuntu3) hardy; urgency=low
+
+  * No source changes, rebuild against newer x264. (LP: #173624)
+
+ -- Brandon Holtsclaw <brandon@imbrandon.com>  Mon, 03 Dec 2007 05:25:41 -0600
+
+mplayer (2:1.0~rc2-0ubuntu2) hardy; urgency=low
+
+  * No source changes, rebuild against newer x264. (LP: #138854)
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Tue, 20 Nov 2007 15:55:53 -0600
+
+mplayer (2:1.0~rc2-0ubuntu1) hardy; urgency=low
+
+  * New upstream version. 
+    - Packaging (LP: #150925)
+    - MP3 Distortion (LP: #85751)
+    - Aspect ratio fixes (LP: #103038, #153543)
+    - Samba support (LP: #85052)
+  * Move 01_default_config.dpatch into bzr.
+  * Drop dpatch from build-depends and debian/rules
+  * Add liblzo2-dev, libdvdnav-dev, libopenal-dev,
+    libjack-dev, libtwolame-dev, libsvga1-dev to build dependencies.
+  * debian/rules:
+    - Build with radio interface support
+    - Build with OpenAL, Jack audio support. (LP: #122042)
+    - Let Xvid support be autodetected for proper linking.
+    - Let Faac support be autodetected for proper linking.
+    - Let fontconfig support be autodetected for proper linking.
+    - Let LIVE555 support be autodetected for proper linking.
+    - Drop DOCS/zh from dh_installdocs
+    - Build with dvdnav support.
+    - Adjust changelog that gets installed.
+  * Add polish translation for .desktop file (LP: #93382)
+  * Adjust configure script to properly link dbus-glib and pulse audio.
+  * Disable joystick by default (LP: #75925)
+  * Adjust configure script to call dvdnav-config properly.
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Sat, 03 Nov 2007 09:26:21 -0400
+
+mplayer (2:1.0~rc1-0ubuntu13) gutsy; urgency=low
+
+  * 01_default_config.dpatch: Fix typo that prevent the screensaver to be
+    disabled (LP: #152080)
+
+ -- Laurent Bigonville <bigon@ubuntu.com>  Sat, 13 Oct 2007 14:28:11 +0200
+
+mplayer (2:1.0~rc1-0ubuntu12) gutsy; urgency=low
+
+  * Add 01_default_config.dpatch.
+    - Sets screensaver by default for non gmplayer. 
+      (LP: #95038), (LP: #139770)
+    - Sets xv as video output for gmplayer and mplayer. 
+      (LP: #65165), (LP: #146307)
+  * Add dpatch to build-depends in debian/control.
+  * Add dpatch support to debian/rules.
+
+ -- Mario Limonciello <superm1@ubuntu.com>  Mon, 08 Oct 2007 01:07:53 -0500
+
+mplayer (2:1.0~rc1-0ubuntu11) gutsy; urgency=low
+
+  * Added Network Audio System (NAS) support  (LP: #110151)
+
+ -- Alfredo Matos <alfredo.matos@digitalself.org>  Thu, 07 Jun 2007 21:53:04 +0100
+
+mplayer (2:1.0~rc1-0ubuntu10) gutsy; urgency=low
+
+  * SECURITY UPDATE: Upstream fix for CVE 2007-2948. Fixes a buffer overrun in
+    the cddb code. (LP: #118855)
+
+ -- William Grant <william@qeuni.net>  Wed, 06 Jun 2007 17:22:22 +1000
+
+mplayer (2:1.0~rc1-0ubuntu9) feisty; urgency=low
+
+  * Rebuild to get correct version of libdirectfb
+  * Modified Maintainer value to match Debian-Maintainer-Field Spec
+
+ -- Sarah Hobbs <hobbsee@ubuntu.com>  Mon,  9 Apr 2007 21:55:23 +1000
+
+mplayer (2:1.0~rc1-0ubuntu8) feisty; urgency=low
+
+  * Fix some formatting in our patches.
+  * etc/examples.conf:
+    - Add ac=mad, to use libmad as first choice.
+  * debian/rules:
+    - Reenable mp3lib again... *sigh*
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Mon, 12 Mar 2007 03:42:49 +0100
+
+mplayer (2:1.0~rc1-0ubuntu7) feisty; urgency=low
+
+  [ Christian Bjälevik ]
+  * debian/rules:
+    - Add --disable-mp3lib to actually disable the damn thing.
+  * DOCS/man/en/mplayer.1:
+    - Remove documentation about -vo aa:help (LP: #43301).
+  * Various files (see bzr diff for info):
+    - Apply patch taken from Mandriva CVS (LP: #53947)
+      to use dbus for disabling gnome-screensaver.
+
+  [ William Grant ]
+  * Enable LADSPA (LP: #67400)
+    - Add ladspa-sdk to Build-Depends.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Sun, 11 Mar 2007 05:43:02 +0100
+
+mplayer (2:1.0~rc1-0ubuntu6) feisty; urgency=low
+
+  * debian/rules:
+    - Disable mp3lib and enable mad (LP: #85751).
+  * debian/control:
+    - Add libmad0-dev to Build-Deps.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Sat, 10 Mar 2007 11:05:40 +0100
+
+mplayer (2:1.0~rc1-0ubuntu5) feisty; urgency=low
+
+  * SECURITY UPDATE: DirectShow decoder heap overflow.
+  * loader/dshow/DS_VideoDecoder.c: added upstream fix.
+  * References
+    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=414072
+
+ -- Kees Cook <kees@ubuntu.com>  Fri,  9 Mar 2007 08:52:34 -0800
+
+mplayer (2:1.0~rc1-0ubuntu4) feisty; urgency=low
+
+  * SECURITY UPDATE: DMO decoder heap overflow.
+  * loader/dmo/DMO_VideoDecoder.c: added upstream fix.
+  * References
+    http://svn.mplayerhq.hu/mplayer/trunk/loader/dmo/DMO_VideoDecoder.c?r1=22019&r2=22204
+    CVE-2007-1246
+
+ -- Kees Cook <kees@ubuntu.com>  Tue,  6 Mar 2007 15:21:26 -0800
+
+mplayer (2:1.0~rc1-0ubuntu3) feisty; urgency=low
+
+  * debian/rules:
+    - Add --enable-mp3lib to CONFIGURE_AUDIO_CODECS (LP: #83580).
+    - Remove --disable-mp3lib. This one took some time to find.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Tue,  6 Feb 2007 19:47:34 +0100
+
+mplayer (2:1.0~rc1-0ubuntu2) feisty; urgency=low
+
+  * debian/rules:
+    - Add --enable-libvorbis to CONFIGURE_AUDIO_CODECS.
+  * debian/{compat,control}:
+    - Bump Standard-Versions and debhelper >=.
+  * Applied patch from: http://0pointer.de/public/mplayer-pulse.patch
+    and adapted it for our current mplayer. Closes: #83493.
+  * debian/{control,rules}
+    - Add Build-Deps on libpulse-dev and --enable-pulse.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Tue,  6 Feb 2007 07:19:34 +0100
+
+mplayer (2:1.0~rc1-0ubuntu1) feisty; urgency=low
+
+  * New upstream version.
+  * Apply RTSP buffer overflow fix patch from upstream.
+  * Remove --enable-{vorbis,x264} and s/internal-tremor/tremor-internal/ in
+    debian/rules. The defaults are detected properly, and forcing x264 now
+    causes it to FTBFS.
+  * Remove DOCS/it from dh_installdocs. Aforementioned directory no longer
+    exists.
+
+ -- William Grant <william.grant@ubuntu.org.au>  Sun,  4 Feb 2007 15:04:46 +1100
+
+mplayer (2:0.99+1.0pre8-0ubuntu8) edgy; urgency=low
+
+  * No-change rebuild against newer libx264-dev (affects
+    Ubuntu: #63842),
+    - RC freeze exception granted by Andrew Mitchell.
+
+ -- Daniel T Chen <crimsun@ubuntu.com>  Thu, 12 Oct 2006 17:07:36 -0400
+
+mplayer (2:0.99+1.0pre8-0ubuntu7) edgy; urgency=low
+
+  * libvo/osd_template.c:
+    - Add patch from Ubuntu #62209 to fix AMD64 FTBFS.
+      Thanks Andreas Schultz.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Tue, 26 Sep 2006 15:15:27 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu6) edgy; urgency=low
+
+  * debian/preinst:
+    - Remove codecs.conf if it exists on the system
+      (thanks Johan Kiviniemi).
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Fri, 22 Sep 2006 20:45:08 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu5) edgy; urgency=low
+
+  * configure:
+    - Revert "if cygwin", we don't want to care changes like that.
+  * etc/example.conf:
+    - Revert vo and make "ao=alsa,". That means prefer alsa and
+      then auto-detect the rest.
+  * libmpcodecs/ve_lavc.c:
+    - Revert our changes. We build against internal ffmpeg again.
+  * debian/control:
+    - Dropped dpatch and libmad0-dev as Build-Deps.
+    - Drop all dummy packages and fix Conflicts/Replaces.
+    - Dropped the field Uploaders. Useless for Ubuntu.
+    - Dropped libavcodec-dev, libavformat-dev, libpostproc-dev
+      from Build-Deps.
+  * debian/rules:
+    - Stop copying config.{guess,sub}, this just add bloat to the
+      diff.
+    - Use --with-codecsdir instead of setting the same for win32,
+      xanim and real. Also drop --enable-{win32,real}, they are
+      implied by --with-codecsdir and enabled on all arches now.
+    - Drop defaults (--datadir and --disable-external-faad).
+    - Dropped libmad, the other two mp3-decoders should be enough.
+    - --enable-dshow was dropped upstream.
+    - Stop installing codecs.conf.
+    - Build against internal ffmpeg.
+
+ -- Christian Bjälevik <nafallo@ubuntu.com>  Thu, 21 Sep 2006 14:18:44 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu4) edgy; urgency=low
+
+  * debian/control,
+    debian/rules:
+    + Use the system's libavcodec, libavformat and libpostproc
+  * debian/rules:
+    + Add hack to enable more runtime-detected CPU optimizations on i386
+  * debian/control:
+    + Build-Depend on libx264-dev (>= 1:0.cvs20060720) to get a compatible
+      version
+  * debian/rules:
+    + disable internal mp3lib. This will enable mad or ffmpeg as
+      replacement (Ubuntu: #52729)
+  * libmpcodecs/ve_lavc.c:
+    + remove stuff that uses a newer libavcodec API than we have
+  * libmpcodecs/ve_x264.c:
+    + fix from upstream svn to build against our latest libx264
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Sun, 23 Jul 2006 13:33:53 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu3) edgy; urgency=low
+
+  * Remove a broken newline in debian/rules to really build with i586 as
+    target
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Sat,  8 Jul 2006 19:50:53 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu2) edgy; urgency=low
+
+  * Don't use --enable-vidix on powerpc. This parameter doesn't exist anymore
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Sat,  8 Jul 2006 19:28:42 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu1) edgy; urgency=low
+
+  * converted to bzr
+  * dropped dpatch, converted them all to bzr branches
+  * remerged all missing branches, except 57_demuxer_heap_overflow,
+    which has been merged upstream
+  * revert nsv-support patch, due to syntax error in codecs.conf
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sat,  8 Jul 2006 15:05:34 +0200
+
+mplayer (2:0.99+1.0pre8-0ubuntu0) UNRELEASED; urgency=low
+
+  * unreleased testversion
+  * new upstream version
+    + far too many changes to list here
+  *  disabled dpatches temporarily:
+     -04_ubuntu-branding.dpatch
+     -57_demuxer_heap_overflow
+     -06_close_gracefully.dpatch
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sat,  8 Jul 2006 12:03:40 +0200
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu8) dapper; urgency=low
+
+  * 07_hig-compliant-desktop-file.dpatch:
+    - Use a more HIG compliant name for mplayer in the .desktop file.
+      Thanks to Matthew East for the patch (Ubuntu: #38205)
+  * 08_nsv-support.dpatch:
+    - Add support for specific NSV files. Thanks to Dana Olson for the patch.
+      (Ubuntu: #44831)
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Mon, 15 May 2006 22:22:34 +0200
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu7) dapper; urgency=low
+
+  * debian/patches/06_close_gracefully.dpatch:
+    + Close gracefully when closing the mplayer window (Ubuntu: #38737)
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Wed, 10 May 2006 16:04:56 +0200
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu6) dapper; urgency=low
+
+  * add libx264-dev to builddeps and activate that in debian rules
+    Thanks to Yagisan (Closes: M#31519)
+  * disable external faad (Closes: M#33828)
+  * add some of the script which upstream distributs in TOOLS/ to
+    /usr/share/doc/mplayer/examples. Please report bugs if you want
+    additional scripts added there.
+
+ -- Reinhard Tartler <siretart@tauware.de>  Sat, 25 Mar 2006 19:14:02 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu5) dapper; urgency=low
+
+  * [SECURITY]: Fix heap overflow in libmpdemux/demuxer.h. Patch
+    retrieved from upstream CVS courtesy of Dennis Kaarsemaker.
+  * References
+    - CVE-2006-0579
+    - http://bugs.gentoo.org/show_bug.cgi?id=122029
+
+ -- Daniel T Chen <crimsun@ubuntu.com>  Sat, 25 Feb 2006 23:19:46 -0800
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu4) dapper; urgency=low
+
+  * added 05_gnome-screensaver-handling.dpatch to add support for
+    gnome-screensaver to the -stop-xscreensaver option 
+
+ -- Oliver Grawert <ogra@ubuntu.com>  Sat, 25 Feb 2006 20:52:36 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu3) dapper; urgency=low
+
+  * Add support for real codecs on powerpc (Closes Malone: #29190)
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Sat, 18 Feb 2006 11:05:18 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu2) dapper; urgency=low
+
+  * enable libaa and libcaca support
+    - enable in debian/rules
+    - fix configure to link mplayer with -laa (update 03_fix-linking.dpatch)
+
+ -- Reinhard Tartler <siretart@ubuntu.com>  Tue, 24 Jan 2006 01:31:46 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20060117-0ubuntu1) dapper; urgency=low
+
+  * New CVS snapshot
+  * Improved Ubuntu branding by using the version from the changelog instead
+    of the default "dev-CVS--Ubuntu-4.0.3"
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Tue, 17 Jan 2006 08:21:48 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu7) dapper; urgency=low
+
+  * Revert last change... I see no way how win32 support could ever work with
+    a 64bit binary on amd64 but when someone has a patch to enable it please
+    send it to me
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Fri,  9 Dec 2005 17:50:36 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu6) dapper; urgency=low
+
+  * Enable win32 support for amd64 (thanks fabbione) :)
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Thu,  8 Dec 2005 23:04:07 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu5) dapper; urgency=low
+
+  * Don't install the mencoder manpage in the mplayer package to prevent a
+    conflict
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Thu,  8 Dec 2005 19:35:18 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu4) dapper; urgency=low
+
+  * Don't install .libdeps in examples
+  * Install {input,codecs,menu}.conf to /etc/mplayer where we had them before
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Thu,  8 Dec 2005 19:15:39 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu3) dapper; urgency=low
+
+  * Stop having mplayer conflict with the mplayer-$arch transitional
+    packages, so the transition can actually happen correctly.
+
+ -- Adam Conrad <adconrad@ubuntu.com>  Thu,  8 Dec 2005 15:43:58 +1100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu2) dapper; urgency=low
+
+  * Add dummy packages for the mplayer-$arch packages we had before
+  * Patch away the CPU runtime detection warning
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Wed,  7 Dec 2005 15:39:24 +0100
+
+mplayer (2:0.99+1.0pre7try2+cvs20051205-0ubuntu1) dapper; urgency=low
+
+  * Initial release.
+  * Completly repackaged
+  * Based on ffmpeg/mplayer CVS 2005-12-05
+  * debian/patches/01_configure.dpatch: fixes live.com bulding.
+    the patch is taken from Marillat's mplayer package
+  * debian/patches/02_mplayer.conf.dpatch: use a better suited config for
+    ubuntu
+
+ -- Sebastian Dröge <slomo@ubuntu.com>  Wed, 05 Dec 2005 14:43:37 +0100
Index: debian-rvm/mplayer.examples
===================================================================
--- debian-rvm/mplayer.examples	(revisión: 0)
+++ debian-rvm/mplayer.examples	(revisión: 0)
@@ -0,0 +1 @@
+TOOLS/*
Index: debian-rvm/mime
===================================================================
--- debian-rvm/mime	(revisión: 0)
+++ debian-rvm/mime	(revisión: 0)
@@ -0,0 +1,20 @@
+application/x-ogg; mplayer %s; description="Ogg Stream"
+application/ogg; mplayer %s; description="Ogg Stream"
+audio/mpeg; mplayer %s; description="MPEG Audio"
+audio/x-mpegurl; mplayer %s; description="Icecast Playlist"
+audio/x-ms-wax; mplayer %s; description="Windows Media Audio"
+audio/x-ms-wma; mplayer %s; description="Windows Media Audio"
+audio/x-pls; mplayer %s; description="MP3 ShoutCast/IceCast Playlist"
+audio/x-scpls; mplayer %s; description="Shoutcast Playlist"
+audio/x-wav; mplayer %s; description="WAV Audio"
+video/mpeg; mplayer %s; description="MPEG Video";
+video/quicktime; mplayer %s; description="Apple QuickTime Video";
+video/x-mpeg; mplayer %s; description="MPEG Video";
+video/x-mpeg2; mplayer %s; description="MPEG-2 Video";
+video/x-msvideo; mplayer %s; description="MS Video (AVI)";
+video/x-ms-afs; mplayer %s; description="Microsoft ASF Video";
+video/x-ms-asf; mplayer %s; description="Microsoft ASF Video";
+video/x-ms-wma; mplayer %s; description="Windows Media Audio";
+video/x-ms-wmv; mplayer %s; description="Windows Media Video";
+video/x-ms-wmx; mplayer %s; description="Windows Media Video";
+video/x-ms-wvx; mplayer %s; description="Windows Media Video";
Index: debian-rvm/patches/05-ass_for_mencoder_embeddedfonts.dpatch
===================================================================
--- debian-rvm/patches/05-ass_for_mencoder_embeddedfonts.dpatch	(revisión: 0)
+++ debian-rvm/patches/05-ass_for_mencoder_embeddedfonts.dpatch	(revisión: 0)
@@ -0,0 +1,500 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 05-ass_for_mencoder_embeddedfonts.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad svn~/DOCS/man/en/mplayer.1 svn/DOCS/man/en/mplayer.1
+--- svn~/DOCS/man/en/mplayer.1	2009-05-20 13:32:19.000000000 +0200
++++ svn/DOCS/man/en/mplayer.1	2009-05-20 13:37:43.000000000 +0200
+@@ -7336,6 +7336,48 @@
+ Threshold below which a pixel value is considered black (default: 32).
+ .RE
+ .
++.TP
++.B fixpts[=options]
++Fixes the presentation timestamps (PTS) of the frames.
++By default, the PTS passed to the next filter is dropped, but the following
++options can change that:
++.RSs
++.IPs print
++Print the incoming PTS.
++.IPs fps=<fps>
++Specify a frame per second value.
++.IPs start=<pts>
++Specify an initial value for the PTS.
++.IPs autostart=<n>
++Uses the 
++.IR n th
++incoming PTS as the initial PTS.
++All previous pts are kept, so setting a huge value or \-1 keeps the PTS
++intact.
++.IPs autofps=<n>
++Uses the 
++.IR n th
++incoming PTS after the end of autostart to determine the framerate.
++.RE
++.sp 1
++.RS
++.I EXAMPLE:
++.RE
++.PD 0
++.RSs
++.IPs "\-vf fixpts=fps=24000/1001,ass,fixpts"
++Generates a new sequence of PTS, uses it for ASS subtitles, then drops it.
++Generating a new sequence is useful when the timestamps are reset during the
++program; this is frequent on DVDs.
++Dropping it may be necessary to avoid confusing encoders.
++.RE
++.PD 1
++.sp 1
++.RS
++.I NOTE:
++Using this filter together with any sort of seeking (including -ss and EDLs)
++may make demons fly out of your nose.
++.RE
+ .
+ .
+ .SH "GENERAL ENCODING OPTIONS (MENCODER ONLY)"
+@@ -7458,6 +7500,14 @@
+ Do not write OpenDML index for AVI files >1GB.
+ .
+ .TP
++.B \-keep\-pts
++Send the original presentation timestamp (PTS) down the filter and encoder
++chain.
++This may cause incorrect output ("badly interleaved") if the original PTS
++are wrong or the framerate is changed, but can be necessary for certain
++filters (such as ASS).
++.
++.TP
+ .B \-noskip
+ Do not skip frames.
+ .
+diff -urNad svn~/Makefile svn/Makefile
+--- svn~/Makefile	2009-05-20 13:32:28.000000000 +0200
++++ svn/Makefile	2009-05-20 13:37:43.000000000 +0200
+@@ -422,6 +422,7 @@
+               libmpcodecs/vf_field.c \
+               libmpcodecs/vf_fil.c \
+               libmpcodecs/vf_filmdint.c \
++              libmpcodecs/vf_fixpts.c \
+               libmpcodecs/vf_flip.c \
+               libmpcodecs/vf_format.c \
+               libmpcodecs/vf_framestep.c \
+diff -urNad svn~/cfg-mencoder.h svn/cfg-mencoder.h
+--- svn~/cfg-mencoder.h	2009-05-20 13:32:28.000000000 +0200
++++ svn/cfg-mencoder.h	2009-05-20 13:37:43.000000000 +0200
+@@ -214,6 +214,9 @@
+ 	{"odml", &write_odml, CONF_TYPE_FLAG, CONF_GLOBAL, 0, 1, NULL},
+ 	{"noodml", &write_odml, CONF_TYPE_FLAG, CONF_GLOBAL, 1, 0, NULL},
+ 
++	{"keep-pts", &keep_pts, CONF_TYPE_FLAG, 0, 0, 1, NULL},
++	{"nokeep-pts", &keep_pts, CONF_TYPE_FLAG, 0, 1, 0, NULL},
++
+ 	// info header strings
+ 	{"info", info_conf, CONF_TYPE_SUBCONFIG, CONF_GLOBAL, 0, 0, NULL},
+ 
+diff -urNad svn~/libass/ass_cache.c svn/libass/ass_cache.c
+--- svn~/libass/ass_cache.c	2009-05-20 13:32:21.000000000 +0200
++++ svn/libass/ass_cache.c	2009-05-20 13:37:43.000000000 +0200
+@@ -293,6 +293,39 @@
+ 	free(value);
+ }
+ 
++static int glyph_compare(void* key1, void* key2, size_t key_size) {
++	glyph_hash_key_t* a = key1;
++	glyph_hash_key_t* b = key2;
++	return
++		a->font == b->font &&
++		a->size == b->size &&
++		a->ch == b->ch &&
++		a->bold == b->bold &&
++		a->italic == b->italic &&
++		a->scale_x == b->scale_x &&
++		a->scale_y == b->scale_y &&
++		a->advance.x == b->advance.x &&
++		a->advance.y == b->advance.y &&
++		a->outline == b->outline;
++}
++
++static unsigned glyph_hash(void* buf, size_t len)
++{
++	glyph_hash_key_t* g = buf;
++	unsigned hval = FNV1_32A_INIT;
++	hval = fnv_32a_buf(&g->font, sizeof(g->font), hval);
++	hval = fnv_32a_buf(&g->size, sizeof(g->size), hval);
++	hval = fnv_32a_buf(&g->ch, sizeof(g->ch), hval);
++	hval = fnv_32a_buf(&g->bold, sizeof(g->bold), hval);
++	hval = fnv_32a_buf(&g->italic, sizeof(g->italic), hval);
++	hval = fnv_32a_buf(&g->scale_x, sizeof(g->scale_x), hval);
++	hval = fnv_32a_buf(&g->scale_y, sizeof(g->scale_y), hval);
++	hval = fnv_32a_buf(&g->advance.x, sizeof(g->advance.x), hval);
++	hval = fnv_32a_buf(&g->advance.y, sizeof(g->advance.y), hval);
++	hval = fnv_32a_buf(&g->outline, sizeof(g->outline), hval);
++	return hval;
++}
++
+ void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+ {
+ 	return hashmap_insert(glyph_cache, key, val);
+@@ -313,7 +346,9 @@
+ 	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
+ 				   sizeof(glyph_hash_val_t),
+ 				   0xFFFF + 13,
+-				   glyph_hash_dtor, NULL, NULL);
++				   glyph_hash_dtor,
++				   glyph_compare,
++				   glyph_hash);
+ }
+ 
+ void ass_glyph_cache_done(void)
+diff -urNad svn~/libmpcodecs/vf.c svn/libmpcodecs/vf.c
+--- svn~/libmpcodecs/vf.c	2009-05-20 13:32:08.000000000 +0200
++++ svn/libmpcodecs/vf.c	2009-05-20 13:37:43.000000000 +0200
+@@ -99,6 +99,7 @@
+ extern const vf_info_t vf_info_blackframe;
+ extern const vf_info_t vf_info_geq;
+ extern const vf_info_t vf_info_ow;
++extern const vf_info_t vf_info_fixpts;
+ 
+ // list of available filters:
+ static const vf_info_t* const filter_list[]={
+@@ -191,6 +192,7 @@
+     &vf_info_yadif,
+     &vf_info_blackframe,
+     &vf_info_ow,
++    &vf_info_fixpts,
+     NULL
+ };
+ 
+diff -urNad svn~/libmpcodecs/vf_fixpts.c svn/libmpcodecs/vf_fixpts.c
+--- svn~/libmpcodecs/vf_fixpts.c	1970-01-01 01:00:00.000000000 +0100
++++ svn/libmpcodecs/vf_fixpts.c	2009-05-20 13:37:43.000000000 +0200
+@@ -0,0 +1,137 @@
++/*
++    Copyright (C) 2007 Nicolas George <nicolas.george@normalesup.org>
++
++    This program is free software; you can redistribute it and/or modify
++    it under the terms of the GNU General Public License as published by
++    the Free Software Foundation; either version 2 of the License, or
++    (at your option) any later version.
++
++    This program is distributed in the hope that it will be useful,
++    but WITHOUT ANY WARRANTY; without even the implied warranty of
++    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++    GNU General Public License for more details.
++
++    You should have received a copy of the GNU General Public License
++    along with this program; if not, write to the Free Software
++    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
++*/
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <inttypes.h>
++
++#include "config.h"
++#include "mp_msg.h"
++#include "help_mp.h"
++
++#include "img_format.h"
++#include "mp_image.h"
++#include "vf.h"
++
++struct vf_priv_s {
++    double current;
++    double step;
++    int autostart;
++    int autostep;
++    unsigned have_step: 1;
++    unsigned print: 1;
++};
++
++static int put_image(vf_instance_t *vf, mp_image_t *src, double pts)
++{
++    struct vf_priv_s *p = vf->priv;
++
++    if(p->print) {
++	if(pts == MP_NOPTS_VALUE)
++	    printf("PTS: undef\n");
++	else
++	    printf("PTS: %f\n", pts);
++    }
++    if(pts != MP_NOPTS_VALUE && p->autostart != 0) {
++	p->current = pts;
++	if(p->autostart > 0)
++	    p->autostart--;
++    } else if(pts != MP_NOPTS_VALUE && p->autostep > 0) {
++	p->step = pts - p->current;
++	p->current = pts;
++	p->autostep--;
++	p->have_step = 1;
++    } else if(p->have_step) {
++	p->current += p->step;
++	pts = p->current;
++    } else {
++	pts = MP_NOPTS_VALUE;
++    }
++    return vf_next_put_image(vf, src, pts);
++}
++
++static void uninit(vf_instance_t *vf)
++{
++    free(vf->priv);
++}
++
++static int parse_args(struct vf_priv_s *p, const char *args)
++{
++    int pos;
++    double num, denom = 1;
++    int iarg;
++
++    while(*args != 0) {
++	pos = 0;
++	if(sscanf(args, "print%n", &pos) == 0 && pos > 0) {
++	    p->print = 1;
++	} else if(sscanf(args, "fps=%lf%n/%lf%n", &num, &pos, &denom, &pos) >= 1
++	    && pos > 0) {
++	    p->step = denom / num;
++	    p->have_step = 1;
++	} else if(sscanf(args, "start=%lf%n", &num, &pos) >= 1 && pos > 0) {
++	    p->current = num;
++	} else if(sscanf(args, "autostart=%d%n", &iarg, &pos) == 1 && pos > 0) {
++	    p->autostart = iarg;
++	} else if(sscanf(args, "autofps=%d%n", &iarg, &pos) == 1 && pos > 0) {
++	    p->autostep = iarg;
++	} else {
++	    mp_msg(MSGT_VFILTER, MSGL_FATAL,
++		"fixpts: unknown suboption: %s\n", args);
++	    return 0;
++	}
++	args += pos;
++	if(*args == ':')
++	    args++;
++    }
++    return 1;
++}
++
++static int open(vf_instance_t *vf, char *args)
++{
++    struct vf_priv_s *p;
++    struct vf_priv_s ptmp = {
++	.current = 0,
++	.step = 0,
++	.autostart = 0,
++	.autostep = 0,
++	.have_step = 0,
++	.print = 0,
++    };
++
++    if(!parse_args(&ptmp, args == NULL ? "" : args))
++	return 0;
++
++    vf->put_image = put_image;
++    vf->uninit = uninit;
++    vf->priv = p = malloc(sizeof(struct vf_priv_s));
++    *p = ptmp;
++    p->current = -p->step;
++
++    return 1;
++}
++
++vf_info_t vf_info_fixpts = {
++  "Fix presentation timestamps",
++  "fixpts",
++  "Nicolas George",
++  "",
++  &open,
++  NULL
++};
+diff -urNad svn~/mencoder.c svn/mencoder.c
+--- svn~/mencoder.c	2009-05-20 13:32:28.000000000 +0200
++++ svn/mencoder.c	2009-05-20 13:37:43.000000000 +0200
+@@ -192,6 +192,7 @@
+ 
+ int auto_expand=1;
+ int encode_duplicates=1;
++int keep_pts=0;
+ 
+ // infos are empty by default
+ char *info_name=NULL;
+@@ -353,6 +354,44 @@
+ 
+ static muxer_t* muxer=NULL;
+ 
++void add_subtitles(char *filename, float fps, int silent)
++{
++    sub_data *subd;
++#ifdef CONFIG_ASS
++    ass_track_t *asst = 0;
++#endif
++
++    if (filename == NULL) return;
++
++    subd = sub_read_file(filename, fps);
++#ifdef CONFIG_ASS
++    if (ass_enabled)
++#ifdef CONFIG_ICONV
++        asst = ass_read_file(ass_library, filename, sub_cp);
++#else
++        asst = ass_read_file(ass_library, filename, 0);
++#endif
++    if (ass_enabled && subd && !asst)
++        asst = ass_read_subdata(ass_library, subd, fps);
++
++    if (!asst && !subd && !silent)
++#else
++    if(!subd && !silent) 
++#endif
++        mp_msg(MSGT_CPLAYER, MSGL_ERR, MSGTR_CantLoadSub,
++		filename_recode(filename));
++ 
++#ifdef CONFIG_ASS
++    if (!asst && !subd) return;
++    ass_track = asst;
++#else
++    if (!subd) return;
++#endif
++    mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_FILE_SUB_FILENAME=%s\n",
++	   filename_recode(filename));
++    subdata = subd;
++}
++
+ void print_wave_header(WAVEFORMATEX *h, int verbose_level);
+ 
+ int main(int argc,char* argv[]){
+@@ -512,6 +551,10 @@
+   m_entry_set_options(mconfig,&filelist[curfile]);
+   filename = filelist[curfile].name;
+ 
++#ifdef CONFIG_ASS
++  ass_library = ass_init();
++#endif
++
+   if(!filename){
+ 	mp_msg(MSGT_CPLAYER, MSGL_FATAL, MSGTR_MissingFilename);
+ 	mencoder_exit(1,NULL);
+@@ -635,26 +678,6 @@
+     }
+   }
+ 
+-// after reading video params we should load subtitles because
+-// we know fps so now we can adjust subtitles time to ~6 seconds AST
+-// check .sub
+-//  current_module="read_subtitles_file";
+-  if(sub_name && sub_name[0]){
+-    subdata=sub_read_file(sub_name[0], sh_video->fps);
+-    if(!subdata) mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CantLoadSub,sub_name[0]);
+-  } else
+-  if(sub_auto && filename) { // auto load sub file ...
+-    char **tmp = NULL;
+-    int i = 0;
+-    char *psub = get_path( "sub/" );
+-    tmp = sub_filenames((psub ? psub : ""), filename);
+-    free(psub);
+-    subdata=sub_read_file(tmp[0], sh_video->fps);
+-    while (tmp[i])
+-      free(tmp[i++]);
+-    free(tmp);
+-  }
+-
+ // set up video encoder:
+ 
+ if (!curfile) { // curfile is non zero when a second file is opened
+@@ -834,12 +857,83 @@
+     ve = sh_video->vfilter;
+   } else sh_video->vfilter = ve;
+     // append 'expand' filter, it fixes stride problems and renders osd:
++#ifdef CONFIG_ASS
++    if (auto_expand && !ass_enabled) { /* we do not want both */
++#else
+     if (auto_expand) {
++#endif
+       char* vf_args[] = { "osd", "1", NULL };
+       sh_video->vfilter=vf_open_filter(sh_video->vfilter,"expand",vf_args);
+     }
++
++#ifdef CONFIG_ASS
++  if(ass_enabled) {
++    int i;
++    int insert = 1;
++    if (vf_settings)
++      for (i = 0; vf_settings[i].name; ++i)
++        if (strcmp(vf_settings[i].name, "ass") == 0) {
++          insert = 0;
++          break;
++        }
++    if (insert) {
++      extern vf_info_t vf_info_ass;
++      vf_info_t* libass_vfs[] = {&vf_info_ass, NULL};
++      char* vf_arg[] = {"auto", "1", NULL};
++      vf_instance_t* vf_ass = vf_open_plugin(libass_vfs,sh_video->vfilter,"ass",vf_arg);
++      if (vf_ass)
++        sh_video->vfilter=(void*)vf_ass;
++      else
++        mp_msg(MSGT_CPLAYER,MSGL_ERR, "ASS: cannot add video filter\n");
++    }
++    if (!keep_pts) {
++      keep_pts = 1;
++      mp_msg(MSGT_MENCODER, MSGL_WARN, "Warning: -ass implies -keep-pts, "
++	"which may cause \"badly interleaved\" files.\n");
++    }
++
++    if (ass_library) {
++      for (i = 0; i < demuxer->num_attachments; ++i) {
++        demux_attachment_t* att = demuxer->attachments + i;
++        if (extract_embedded_fonts &&
++            att->name && att->type && att->data && att->data_size &&
++            (strcmp(att->type, "application/x-truetype-font") == 0 ||
++             strcmp(att->type, "application/x-font") == 0))
++          ass_add_font(ass_library, att->name, att->data, att->data_size);
++      }
++    }
++  }
++#endif
++
+     sh_video->vfilter=append_filters(sh_video->vfilter);
+ 
++#ifdef CONFIG_ASS
++  if (ass_enabled)
++    ((vf_instance_t *)sh_video->vfilter)->control(sh_video->vfilter, VFCTRL_INIT_EOSD, ass_library);
++#endif
++
++// after reading video params we should load subtitles because
++// we know fps so now we can adjust subtitles time to ~6 seconds AST
++// check .sub
++//  current_module="read_subtitles_file";
++  if(sub_name && sub_name[0]){
++    for (i = 0; sub_name[i] != NULL; ++i) 
++        add_subtitles (sub_name[i], sh_video->fps, 0); 
++  } else
++  if(sub_auto && filename) { // auto load sub file ...
++    char **tmp = NULL;
++    int i = 0;
++    char *psub = get_path( "sub/" );
++    tmp = sub_filenames((psub ? psub : ""), filename);
++    free(psub);
++    while (tmp[i])
++    {
++      add_subtitles (tmp[i], sh_video->fps, 0);
++      free(tmp[i++]);
++    }
++    free(tmp);
++  }
++
+     mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+     init_best_video_codec(sh_video,video_codec_list,video_fm_list);
+     mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+@@ -1295,7 +1389,8 @@
+     // decode_video will callback down to ve_*.c encoders, through the video filters
+     {void *decoded_frame = decode_video(sh_video,frame_data.start,frame_data.in_size,
+       skip_flag>0 && (!sh_video->vfilter || ((vf_instance_t *)sh_video->vfilter)->control(sh_video->vfilter, VFCTRL_SKIP_NEXT_FRAME, 0) != CONTROL_TRUE), MP_NOPTS_VALUE);
+-    blit_frame = decoded_frame && filter_video(sh_video, decoded_frame, MP_NOPTS_VALUE);}
++    blit_frame = decoded_frame && filter_video(sh_video, decoded_frame,
++	keep_pts ? sh_video->pts : MP_NOPTS_VALUE);}
+ 
+     if (sh_video->vf_initialized < 0) mencoder_exit(1, NULL);
+ 

Cambios de propiedades en debian-rvm/patches/05-ass_for_mencoder_embeddedfonts.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/10-gnome-screensave.dpatch
===================================================================
--- debian-rvm/patches/10-gnome-screensave.dpatch	(revisión: 0)
+++ debian-rvm/patches/10-gnome-screensave.dpatch	(revisión: 0)
@@ -0,0 +1,65 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 05-version.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -ru mplayer-svn/libvo/x11_common.c mplayer.new/libvo/x11_common.c
+--- mplayer-svn/libvo/x11_common.c	2008-01-15 12:46:47.000000000 +0000
++++ mplayer-svn.new/libvo/x11_common.c	2008-01-15 12:37:26.000000000 +0000
+@@ -74,6 +74,7 @@
+ int stop_xscreensaver = 0;
+ 
+ static int dpms_disabled = 0;
++static int gnome_screensaver_was_running = 0;
+ 
+ char *mDisplayName = NULL;
+ Display *mDisplay = NULL;
+@@ -1632,6 +1633,12 @@
+     if (!screensaver_off)
+         return;
+     screensaver_off = 0;
++    if (gnome_screensaver_was_running && stop_xscreensaver)
++    {
++        system
++            ("gconftool-2 --type bool --set /apps/gnome-screensaver/idle_activation_enabled true 2>/dev/null >/dev/null");
++        gnome_screensaver_was_running = 0;
++    }
+     if (xss_suspend(False))
+         return;
+ #ifdef HAVE_XDPMS
+@@ -1664,6 +1671,7 @@
+         dpms_disabled = 0;
+     }
+ #endif
++
+ }
+ 
+ void saver_off(Display * mDisplay)
+@@ -1673,6 +1681,16 @@
+     if (screensaver_off)
+         return;
+     screensaver_off = 1;
++    if (stop_xscreensaver && !gnome_screensaver_was_running)
++    {
++        gnome_screensaver_was_running =
++            (system
++            ("gconftool-2 --get /apps/gnome-screensaver/idle_activation_enabled | grep true 2>/dev/null >/dev/null")
++            == 0);
++        if (gnome_screensaver_was_running)
++            system
++                ("gconftool-2 --type bool --set /apps/gnome-screensaver/idle_activation_enabled false 2>/dev/null >/dev/null");
++    }
+     if (xss_suspend(True))
+         return;
+ #ifdef HAVE_XDPMS
+@@ -1693,6 +1711,7 @@
+         }
+     }
+ #endif
++
+ }
+ 
+ static XErrorHandler old_handler = NULL;
+

Cambios de propiedades en debian-rvm/patches/10-gnome-screensave.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/12-codecs.dpatch
===================================================================
--- debian-rvm/patches/12-codecs.dpatch	(revisión: 0)
+++ debian-rvm/patches/12-codecs.dpatch	(revisión: 0)
@@ -0,0 +1,31 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 12-codecs.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad svn~/etc/codecs.conf svn/etc/codecs.conf
+--- svn~/etc/codecs.conf	2009-03-02 10:28:24.000000000 +0100
++++ svn/etc/codecs.conf	2009-03-02 10:39:22.000000000 +0100
+@@ -857,6 +857,20 @@
+   dll h264_vdpau
+   out VDPAU_H264
+ 
++videocodec coreserve
++  info "CoreAVC DShow H264 decoder for x86 - http://corecodec.org/"
++  status working
++  format 0x10000005
++  fourcc H264,h264 H264
++  fourcc X264,x264
++  fourcc avc1,AVC1 AVC1
++  fourcc davc,DAVC
++  fourcc VSSH
++  driver dshowserver
++  dll "CoreAVCDecoder.ax"
++  guid 0x09571a4b, 0xf1fe, 0x4c60, 0x97, 0x60, 0xde, 0x6d, 0x31, 0x0c, 0x7c, 0x31
++  out YV12,IYUV,I420,YUY2
++
+ videocodec ffsvq3
+   info "FFmpeg Sorenson Video v3 (SVQ3)"
+   status working

Cambios de propiedades en debian-rvm/patches/12-codecs.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/13-wmapro.dpatch
===================================================================
--- debian-rvm/patches/13-wmapro.dpatch	(revisión: 0)
+++ debian-rvm/patches/13-wmapro.dpatch	(revisión: 0)
@@ -0,0 +1,2502 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 13-wmapro.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad svn~/etc/codecs.conf svn/etc/codecs.conf
+--- svn~/etc/codecs.conf	2009-05-28 10:50:02.000000000 +0200
++++ svn/etc/codecs.conf	2009-05-28 10:53:13.000000000 +0200
+@@ -3600,6 +3600,14 @@
+   driver ffmpeg
+   dll "wmav2"
+ 
++audiocodec ffwmapro
++  info "FFmpeg WMA Pro audio"
++  status untested
++  format 0x162
++  fourcc "WMA3"
++  driver ffmpeg
++  dll "wmapro"
++
+ audiocodec ffmac3
+   info "Macintosh Audio Compression and Expansion 3:1"
+   status untested
+diff -urNad svn~/libavcodec/Makefile svn/libavcodec/Makefile
+--- svn~/libavcodec/Makefile	2009-05-20 13:32:33.000000000 +0200
++++ svn/libavcodec/Makefile	2009-05-28 10:53:41.000000000 +0200
+@@ -255,6 +255,7 @@
+ OBJS-$(CONFIG_WMAV1_ENCODER)           += wmaenc.o wma.o
+ OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o
+ OBJS-$(CONFIG_WMAV2_ENCODER)           += wmaenc.o wma.o
++OBJS-$(CONFIG_WMAPRO_DECODER)          += wma3dec.o
+ OBJS-$(CONFIG_WMV1_DECODER)            += h263dec.o h263.o mpeg12data.o mpegvideo.o error_resilience.o
+ OBJS-$(CONFIG_WMV1_ENCODER)            += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o mpeg12data.o mpegvideo.o error_resilience.o
+ OBJS-$(CONFIG_WMV2_DECODER)            += wmv2dec.o wmv2.o msmpeg4.o msmpeg4data.o h263dec.o h263.o intrax8.o intrax8dsp.o mpeg12data.o mpegvideo.o error_resilience.o
+diff -urNad svn~/libavcodec/allcodecs.c svn/libavcodec/allcodecs.c
+--- svn~/libavcodec/allcodecs.c	2009-05-20 13:32:33.000000000 +0200
++++ svn/libavcodec/allcodecs.c	2009-05-28 10:53:41.000000000 +0200
+@@ -231,6 +231,7 @@
+     REGISTER_DECODER (WAVPACK, wavpack);
+     REGISTER_ENCDEC  (WMAV1, wmav1);
+     REGISTER_ENCDEC  (WMAV2, wmav2);
++    REGISTER_DECODER (WMAPRO, wmapro);  
+     REGISTER_DECODER (WS_SND1, ws_snd1);
+ 
+     /* PCM codecs */
+diff -urNad svn~/libavcodec/avcodec.h svn/libavcodec/avcodec.h
+--- svn~/libavcodec/avcodec.h	2009-05-20 13:32:33.000000000 +0200
++++ svn/libavcodec/avcodec.h	2009-05-28 10:53:01.000000000 +0200
+@@ -398,7 +398,7 @@
+ #define CH_LAYOUT_STEREO_DOWNMIX    (CH_STEREO_LEFT|CH_STEREO_RIGHT)
+ 
+ /* in bytes */
+-#define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
++#define AVCODEC_MAX_AUDIO_FRAME_SIZE 1130496
+ 
+ /**
+  * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
+diff -urNad svn~/libavcodec/wma3.h svn/libavcodec/wma3.h
+--- svn~/libavcodec/wma3.h	1970-01-01 01:00:00.000000000 +0100
++++ svn/libavcodec/wma3.h	2009-05-28 10:52:37.000000000 +0200
+@@ -0,0 +1,163 @@
++/*
++ * WMA 9/3/PRO compatible decoder
++ * Copyright (c) 2007 Baptiste Coudurier, Benjamin Larsson, Ulion
++ * Copyright (c) 2008 - 2009 Sascha Sommer
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++/**
++ * @file  libavcodec/wma3.h
++ * @brief wmapro specific structs and defines
++ */
++
++#ifndef AVCODEC_WMA3_H
++#define AVCODEC_WMA3_H
++
++#include "wma3data.h"
++#include "dsputil.h"
++
++/* current decoder limitations */
++#define MAX_CHANNELS    8                                    ///< max number of handled channels
++#define MAX_SUBFRAMES  32                                    ///< max number of subframes per channel
++#define MAX_BANDS      29                                    ///< max number of scale factor bands
++#define MAX_FRAMESIZE  16384                                 ///< maximum compressed frame size
++#define MAX_FRAMEBITS  (MAX_FRAMESIZE << 3)                  ///< maximum frame size in bits
++
++/* size of block defines taken from wma.h */
++#define BLOCK_MIN_BITS  7                                    ///< log2 of min block size
++#define BLOCK_MAX_BITS 12                                    ///< log2 of max block size
++#define BLOCK_MIN_SIZE (1 << BLOCK_MIN_BITS)                 ///< minimum block size
++#define BLOCK_MAX_SIZE (1 << BLOCK_MAX_BITS)                 ///< maximum block size
++#define BLOCK_NB_SIZES (BLOCK_MAX_BITS - BLOCK_MIN_BITS + 1) ///< possible block sizes
++
++/**
++ * @brief decoder context for a single channel
++ */
++typedef struct {
++    int      prev_block_len;                          ///< length of the previous block
++    uint8_t  transmit_coefs;                          ///< transmit coefficients
++    uint8_t  num_subframes;                           ///< number of subframes
++    uint16_t subframe_len[MAX_SUBFRAMES];             ///< subframe length in samples
++    uint16_t subframe_offset[MAX_SUBFRAMES];          ///< subframe position
++    uint8_t  cur_subframe;                            ///< subframe index
++    uint16_t channel_len;                             ///< channel length in samples
++    uint16_t decoded_samples;                         ///< already processed samples
++    uint8_t  grouped;                                 ///< channel is part of a group
++    int      quant_step_modifier;                     ///< deviation from the main quantization step
++    int      transmit_sf;                             ///< transmit scale factors
++    int      reuse_sf;                                ///< share scale factors between subframes
++    int      scale_factor_step;                       ///< scaling step
++    int      max_scale_factor;                        ///< maximum scale factor
++    int      scale_factors[MAX_BANDS];                ///< scale factor values
++    int      resampled_scale_factors[MAX_BANDS];      ///< scale factors from a previous block
++    int      scale_factor_block_len;                  ///< scale factor reference block length
++    float*   coeffs;                                  ///< pointer to the decode buffer
++    DECLARE_ALIGNED_16(float, out[2*BLOCK_MAX_SIZE]); ///< output buffer
++} WMA3ChannelCtx;
++
++/**
++ * @brief channel group for channel transformations
++ */
++typedef struct {
++    int   num_channels;
++    int   no_rotation;                                     ///< controls the type of the transform
++    int   transform;                                       ///< also controls the type of the transform
++    char  transform_band[MAX_BANDS];                       ///< controls if the transform is enabled for a certain band
++    char  rotation_offset[MAX_CHANNELS * MAX_CHANNELS];
++    char  positive[MAX_CHANNELS * MAX_CHANNELS];           ///< FIXME: What are these numbers used for?
++    float decorrelation_matrix[MAX_CHANNELS*MAX_CHANNELS];
++    char  use_channel[MAX_CHANNELS];
++} WMA3ChannelGroup;
++
++/**
++ * @brief main decoder context
++ */
++typedef struct WMA3DecodeContext {
++    /* generic decoder variables */
++    AVCodecContext*  avctx;                         ///< codec context for av_log
++    DSPContext       dsp;                           ///< accelerated dsp functions
++    uint8_t          frame_data[MAX_FRAMESIZE +
++                      FF_INPUT_BUFFER_PADDING_SIZE];///< compressed frame data
++    MDCTContext      mdct_ctx[BLOCK_NB_SIZES];      ///< MDCT context per block size
++    DECLARE_ALIGNED_16(float, tmp[BLOCK_MAX_SIZE]); ///< imdct output buffer
++    float*           windows[BLOCK_NB_SIZES];       ///< window per block size
++    VLC              sf_vlc;                        ///< scale factor dpcm vlc
++    VLC              sf_rl_vlc;                     ///< scale factor run length vlc
++    VLC              vec4_vlc;                      ///< 4 coefficients per symbol
++    VLC              vec2_vlc;                      ///< 2 coefficients per symbol
++    VLC              vec1_vlc;                      ///< 1 coefficient per symbol
++    VLC              coef_vlc[2];                   ///< coefficient run length vlc codes
++    int              coef_max[2];                   ///< max length of vlc codes
++
++    /* frame size dependent frame information (set during initialization) */
++    uint8_t          lossless;                      ///< lossless mode
++    unsigned int     decode_flags;                  ///< used compression features
++    uint8_t          len_prefix;                    ///< frame is prefixed with its length
++    uint8_t          dynamic_range_compression;     ///< frame contains DRC data
++    uint8_t          sample_bit_depth;              ///< bits per sample
++    uint16_t         samples_per_frame;             ///< number of samples to output
++    uint16_t         log2_frame_size;               ///< frame size
++    int8_t           num_channels;                  ///< number of channels
++    int8_t           lfe_channel;                   ///< lfe channel index
++    const float***   def_decorrelation_mat;         ///< default decorrelation matrix
++    uint8_t          allow_subframes;               ///< frames may contain subframes
++    uint8_t          max_num_subframes;             ///< maximum number of subframes
++    int8_t           num_possible_block_sizes;      ///< nb of supported block sizes
++    uint16_t         min_samples_per_subframe;      ///< minimum samples per subframe
++    int*             num_sfb;                       ///< scale factor bands per block size
++    int*             sfb_offsets;                   ///< scale factor band offsets
++    int*             sf_offsets;                    ///< scale factor resample matrix
++    int*             subwoofer_cutoffs;             ///< subwoofer cutoff values
++
++    /* packet decode state */
++    uint8_t          packet_sequence_number;        ///< current packet number
++    int              num_saved_bits;                ///< saved number of bits
++    int              frame_offset;                  ///< frame offset in the bit reservoir
++    int              subframe_offset;               ///< subframe offset in the bit reservoir
++    uint8_t          bit5;                          ///< padding bit? (CBR files)
++    uint8_t          bit6;                          ///< unknown
++    uint8_t          packet_loss;                   ///< set in case of bitstream error
++
++    /* frame decode state */
++    unsigned int     frame_num;                     ///< current frame number
++    GetBitContext    gb;                            ///< bitstream reader context
++    int              buf_bit_size;                  ///< buffer size in bits
++    int16_t*         samples;                       ///< current samplebuffer pointer
++    int16_t*         samples_end;                   ///< maximum samplebuffer pointer
++    uint8_t          drc_gain;                      ///< gain for the DRC tool
++    int              skip_frame;                    ///< skip output step
++    int              parsed_all_subframes;          ///< all subframes decoded?
++
++    /* subframe/block decode state */
++    int              subframe_len;                  ///< current subframe length
++    int              channels_for_cur_subframe;     ///< number of channels that contain the subframe
++    int              channel_indexes_for_cur_subframe[MAX_CHANNELS];
++    int              cur_subwoofer_cutoff;          ///< subwoofer cutoff value
++    int              num_bands;                     ///< number of scale factor bands
++    int*             cur_sfb_offsets;               ///< sfb offsets for the current block
++    int              quant_step;                    ///< quantization step
++    int              esc_len;                       ///< length of escaped coefficients
++
++    uint8_t          num_chgroups;                  ///< number of channel groups
++    WMA3ChannelGroup chgroup[MAX_CHANNELS];         ///< channel group information
++
++    WMA3ChannelCtx   channel[MAX_CHANNELS];         ///< per channel data
++} WMA3DecodeContext;
++
++#endif /* AVCODEC_WMA3_H */
++
+diff -urNad svn~/libavcodec/wma3data.h svn/libavcodec/wma3data.h
+--- svn~/libavcodec/wma3data.h	1970-01-01 01:00:00.000000000 +0100
++++ svn/libavcodec/wma3data.h	2009-05-28 10:52:37.000000000 +0200
+@@ -0,0 +1,588 @@
++/*
++ * WMA 9/3/PRO compatible decoder
++ * Copyright (c) 2007 Baptiste Coudurier, Benjamin Larsson, Ulion
++ * Copyright (c) 2008 - 2009 Sascha Sommer
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++/**
++ * @file  libavcodec/wma3data.h
++ * @brief tables for wmapro decoding
++ */
++
++#ifndef AVCODEC_WMA3DATA_H
++#define AVCODEC_WMA3DATA_H
++
++/**
++ * @brief frequencies to divide the frequency spectrum into scale factor bands
++ */
++static const uint16_t ff_wma3_critical_freq[] = {
++     100,   200,    300,    400,    510,    630,    770,
++     920,  1080,   1270,   1480,   1720,   2000,   2320,
++    2700,  3150,   3700,   4400,   5300,   6400,   7700,
++    9500, 12000,  15500,  20675,  28575,  41375,  63875,
++};
++
++
++/**
++ * @name huffman tables for DPCM-coded scale factors
++ * @{
++ */
++#define FF_WMA3_HUFF_SCALE_SIZE 121
++#define FF_WMA3_HUFF_SCALE_MAXBITS 19
++static const uint32_t ff_wma3_scale_huffcodes[FF_WMA3_HUFF_SCALE_SIZE] = {
++    0x0E639, 0x0E6C2, 0x0E6C1, 0x0E6C0, 0x0E63F, 0x0E63E, 0x0E63D, 0x0E63C,
++    0x0E63B, 0x0E63A, 0x0E638, 0x0E637, 0x0E636, 0x0E635, 0x0E634, 0x0E632,
++    0x0E633, 0x0E620, 0x0737B, 0x0E610, 0x0E611, 0x0E612, 0x0E613, 0x0E614,
++    0x0E615, 0x0E616, 0x0E617, 0x0E618, 0x0E619, 0x0E61A, 0x0E61B, 0x0E61C,
++    0x0E61D, 0x0E61E, 0x0E61F, 0x0E6C3, 0x0E621, 0x0E622, 0x0E623, 0x0E624,
++    0x0E625, 0x0E626, 0x0E627, 0x0E628, 0x0E629, 0x0E62A, 0x0E62B, 0x0E62C,
++    0x0E62D, 0x0E62E, 0x0E62F, 0x0E630, 0x0E631, 0x01CDF, 0x00E60, 0x00399,
++    0x000E7, 0x0001D, 0x00000, 0x00001, 0x00001, 0x00001, 0x00002, 0x00006,
++    0x00002, 0x00007, 0x00006, 0x0000F, 0x00038, 0x00072, 0x0039A, 0x0E6C4,
++    0x0E6C5, 0x0E6C6, 0x0E6C7, 0x0E6C8, 0x0E6C9, 0x0E6CA, 0x0E6CB, 0x0E6CC,
++    0x0E6CD, 0x0E6CE, 0x0E6CF, 0x0E6D0, 0x0E6D1, 0x0E6D2, 0x0E6D3, 0x0E6D4,
++    0x0E6D5, 0x0E6D6, 0x0E6D7, 0x0E6D8, 0x0E6D9, 0x0E6DA, 0x0E6DB, 0x0E6DC,
++    0x0E6DD, 0x0E6DE, 0x0E6DF, 0x0E6E0, 0x0E6E1, 0x0E6E2, 0x0E6E3, 0x0E6E4,
++    0x0E6E5, 0x0E6E6, 0x0E6E7, 0x0E6E8, 0x0E6E9, 0x0E6EA, 0x0E6EB, 0x0E6EC,
++    0x0E6ED, 0x0E6EE, 0x0E6EF, 0x0E6F0, 0x0E6F1, 0x0E6F2, 0x0E6F3, 0x0E6F4,
++    0x0E6F5,
++};
++
++static const uint8_t ff_wma3_scale_huffbits[FF_WMA3_HUFF_SCALE_SIZE] = {
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 18, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 16, 15, 13,
++    11,  8,  5,  2,  1,  3,  5,  6,
++     6,  7,  7,  7,  9, 10, 13, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19, 19, 19, 19, 19, 19, 19, 19,
++    19,
++};
++/** @} */
++
++
++/**
++ * @name huffman, run and level tables for run length coded scale factors
++ * @{
++ */
++#define FF_WMA3_HUFF_SCALE_RL_SIZE 120
++#define FF_WMA3_HUFF_SCALE_RL_MAXBITS 21
++static const uint32_t ff_wma3_scale_rl_huffcodes[FF_WMA3_HUFF_SCALE_RL_SIZE] = {
++    0x00010C, 0x000001, 0x10FE2A, 0x000003, 0x000003, 0x000001, 0x000013,
++    0x000020, 0x000029, 0x000014, 0x000016, 0x000045, 0x000049, 0x00002F,
++    0x000042, 0x00008E, 0x00008F, 0x000129, 0x000009, 0x00000D, 0x0004AC,
++    0x00002C, 0x000561, 0x0002E6, 0x00087C, 0x0002E2, 0x00095C, 0x000018,
++    0x000001, 0x000016, 0x000044, 0x00002A, 0x000007, 0x000159, 0x000143,
++    0x000128, 0x00015A, 0x00012D, 0x00002B, 0x0000A0, 0x000142, 0x00012A,
++    0x0002EF, 0x0004AF, 0x00087D, 0x004AE9, 0x0043F9, 0x000067, 0x000199,
++    0x002B05, 0x001583, 0x0021FE, 0x10FE2C, 0x000004, 0x00002E, 0x00010D,
++    0x00000A, 0x000244, 0x000017, 0x000245, 0x000011, 0x00010E, 0x00012C,
++    0x00002A, 0x00002F, 0x000121, 0x000046, 0x00087E, 0x0000BA, 0x000032,
++    0x0087F0, 0x0056DC, 0x0002EC, 0x0043FA, 0x002B6F, 0x004AE8, 0x0002B7,
++    0x10FE2B, 0x000001, 0x000051, 0x000010, 0x0002EE, 0x000B9C, 0x002576,
++    0x000198, 0x0056DD, 0x0000CD, 0x000AC0, 0x000170, 0x004AEF, 0x00002D,
++    0x0004AD, 0x0021FF, 0x0005CF, 0x002B04, 0x10FE29, 0x10FE28, 0x0002ED,
++    0x002E74, 0x021FC4, 0x004AEE, 0x010FE3, 0x087F17, 0x000000, 0x000097,
++    0x0002E3, 0x000ADA, 0x002575, 0x00173B, 0x0043FB, 0x002E75, 0x10FE2D,
++    0x0015B6, 0x00056C, 0x000057, 0x000123, 0x000120, 0x00021E, 0x000172,
++    0x0002B1,
++};
++
++static const uint8_t ff_wma3_scale_rl_huffbits[FF_WMA3_HUFF_SCALE_RL_SIZE] = {
++     9,  2, 21,  2,  4,  5,  5,
++     6,  6,  7,  7,  7,  7,  6,
++     7,  8,  8,  9, 10, 10, 11,
++    12, 11, 12, 12, 12, 12, 11,
++     4,  5,  7,  8,  9,  9,  9,
++     9,  9,  9,  8,  8,  9,  9,
++    12, 11, 12, 15, 15, 13, 15,
++    14, 13, 14, 21,  5,  6,  9,
++    10, 10, 11, 10, 11,  9,  9,
++     6,  8,  9,  7, 12, 10, 12,
++    16, 15, 12, 15, 14, 15, 10,
++    21,  6,  7, 11, 12, 14, 14,
++    15, 15, 14, 12, 11, 15, 12,
++    11, 14, 13, 14, 21, 21, 12,
++    16, 18, 15, 17, 20,  7,  8,
++    12, 12, 14, 15, 15, 16, 21,
++    13, 11,  7,  9,  9, 10, 11,
++    10,
++};
++
++
++static const uint8_t ff_wma3_scale_rl_run[FF_WMA3_HUFF_SCALE_RL_SIZE] = {
++     0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
++    16, 17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
++    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,
++     4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
++    23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
++    17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
++     0,  1,  0,  1,  0,  1,
++};
++
++static const uint8_t ff_wma3_scale_rl_level[FF_WMA3_HUFF_SCALE_RL_SIZE] = {
++     0,  0,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
++     2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
++     3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,
++     4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
++     4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
++     5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
++     7,  7,  8,  8,  9,  9,
++};
++/** @} */
++
++
++/**
++ * @name huffman, run and level codes for run length coded coefficients
++ * @{
++ */
++#define FF_WMA3_HUFF_COEF0_SIZE 272
++#define FF_WMA3_HUFF_COEF0_MAXBITS 21
++static const uint32_t ff_wma3_coef0_huffcodes[FF_WMA3_HUFF_COEF0_SIZE] = {
++    0x00004A, 0x00002B, 0x000000, 0x000003, 0x000006, 0x000009, 0x00000F,
++    0x000010, 0x000016, 0x000011, 0x000016, 0x000028, 0x00002F, 0x000026,
++    0x000029, 0x000045, 0x000055, 0x00005D, 0x000042, 0x00004E, 0x000051,
++    0x00005E, 0x00008D, 0x0000A8, 0x0000AD, 0x000080, 0x000096, 0x00009F,
++    0x0000AA, 0x0000BE, 0x00011C, 0x000153, 0x000158, 0x000170, 0x000104,
++    0x00010D, 0x000105, 0x000103, 0x00012F, 0x000177, 0x000175, 0x000157,
++    0x000174, 0x000225, 0x00023B, 0x00020D, 0x00021F, 0x000281, 0x00027B,
++    0x000282, 0x0002AC, 0x0002FD, 0x00044F, 0x000478, 0x00044D, 0x0002EC,
++    0x00044E, 0x000564, 0x000409, 0x00040B, 0x000501, 0x000545, 0x0004F3,
++    0x000541, 0x00043B, 0x0004F1, 0x0004F4, 0x0008FD, 0x000A94, 0x000811,
++    0x000B88, 0x000B91, 0x000B93, 0x0008EA, 0x000899, 0x000B8A, 0x000972,
++    0x0009E5, 0x000A8F, 0x000A84, 0x000A8E, 0x000A00, 0x000830, 0x0008E8,
++    0x000B95, 0x000871, 0x00083A, 0x000814, 0x000873, 0x000BFE, 0x001728,
++    0x001595, 0x001712, 0x00102A, 0x001021, 0x001729, 0x00152E, 0x0013C3,
++    0x001721, 0x001597, 0x00151B, 0x0010F2, 0x001403, 0x001703, 0x001503,
++    0x001708, 0x0013C1, 0x00170E, 0x00170C, 0x0010E1, 0x0011EA, 0x001020,
++    0x001500, 0x0017FA, 0x001704, 0x001705, 0x0017F0, 0x0017FB, 0x0021E6,
++    0x002B2D, 0x0020C6, 0x002B29, 0x002E4A, 0x0023AC, 0x001519, 0x0023F3,
++    0x002B2C, 0x0021C0, 0x0017FE, 0x0023D7, 0x0017F9, 0x0012E7, 0x0013C0,
++    0x002261, 0x0023D3, 0x002057, 0x002056, 0x0021D2, 0x0020C7, 0x0023D2,
++    0x0020EC, 0x0044C0, 0x002FE2, 0x00475B, 0x002A03, 0x002FE3, 0x0021E2,
++    0x0021D0, 0x002A31, 0x002E13, 0x002E05, 0x0047E5, 0x00000E, 0x000024,
++    0x000088, 0x0000B9, 0x00010C, 0x000224, 0x0002B3, 0x000283, 0x0002ED,
++    0x00047B, 0x00041E, 0x00043D, 0x0004F5, 0x0005FD, 0x000A92, 0x000B96,
++    0x000838, 0x000971, 0x000B83, 0x000B80, 0x000BF9, 0x0011D3, 0x0011E8,
++    0x0011D7, 0x001527, 0x0011F8, 0x001073, 0x0010F0, 0x0010E4, 0x0017F8,
++    0x001062, 0x001402, 0x0017E3, 0x00151A, 0x001077, 0x00152B, 0x00170D,
++    0x0021D3, 0x002E41, 0x0013C2, 0x000029, 0x0000A9, 0x00025D, 0x000419,
++    0x000544, 0x000B8B, 0x0009E4, 0x0011D2, 0x001526, 0x001724, 0x0012E6,
++    0x00150B, 0x0017FF, 0x002E26, 0x002E4B, 0x002B28, 0x0021E3, 0x002A14,
++    0x00475A, 0x002E12, 0x000057, 0x00023E, 0x000A90, 0x000BF0, 0x001072,
++    0x001502, 0x0023D6, 0x0020ED, 0x002A30, 0x0044C7, 0x00008C, 0x00047F,
++    0x00152A, 0x002262, 0x002E04, 0x0000A1, 0x0005F9, 0x000173, 0x000875,
++    0x000171, 0x00152D, 0x0002E3, 0x0017E2, 0x0002AD, 0x0021C1, 0x000479,
++    0x0021E7, 0x00041F, 0x005C4E, 0x000543, 0x005C4F, 0x000A91, 0x00898D,
++    0x000B97, 0x008746, 0x000970, 0x008745, 0x000B85, 0x00A856, 0x00152F,
++    0x010E8E, 0x0010E5, 0x00A857, 0x00170F, 0x021D11, 0x002A58, 0x010E8F,
++    0x002E40, 0x021D13, 0x002A59, 0x043A25, 0x002A02, 0x043A21, 0x0044C1,
++    0x087448, 0x0047E4, 0x043A20, 0x00542A, 0x087449, 0x00898C,
++};
++
++static const uint8_t ff_wma3_coef0_huffbits[FF_WMA3_HUFF_COEF0_SIZE] = {
++     8,  7,  2,  3,  3,  4,  4,
++     5,  5,  6,  6,  6,  6,  7,
++     7,  7,  7,  7,  8,  8,  8,
++     8,  8,  8,  8,  9,  9,  9,
++     9,  9,  9,  9,  9,  9, 10,
++    10, 10, 10, 10, 10, 10, 10,
++    10, 10, 10, 11, 11, 11, 11,
++    11, 11, 11, 11, 11, 11, 11,
++    11, 11, 12, 12, 12, 12, 12,
++    12, 12, 12, 12, 12, 12, 13,
++    12, 12, 12, 12, 12, 12, 13,
++    13, 13, 13, 13, 13, 13, 12,
++    12, 13, 13, 13, 13, 13, 13,
++    13, 13, 14, 14, 13, 13, 14,
++    13, 13, 14, 14, 14, 14, 14,
++    14, 14, 14, 14, 14, 13, 14,
++    14, 14, 14, 14, 14, 14, 15,
++    14, 15, 14, 14, 14, 14, 14,
++    14, 15, 14, 14, 14, 14, 14,
++    14, 14, 15, 15, 15, 15, 14,
++    15, 15, 15, 15, 15, 15, 15,
++    15, 15, 15, 15, 15,  4,  7,
++     8,  9, 10, 10, 10, 11, 11,
++    11, 12, 12, 12, 12, 12, 12,
++    13, 13, 13, 13, 13, 13, 13,
++    13, 13, 13, 14, 14, 14, 14,
++    14, 14, 14, 14, 14, 13, 14,
++    15, 14, 14,  6,  9, 11, 12,
++    12, 12, 13, 13, 13, 13, 14,
++    14, 14, 14, 14, 14, 15, 15,
++    15, 15,  7, 10, 12, 13, 14,
++    14, 14, 15, 15, 15,  8, 11,
++    13, 14, 15,  9, 12,  9, 13,
++    10, 13, 10, 14, 11, 15, 11,
++    15, 12, 15, 12, 15, 12, 16,
++    12, 17, 13, 17, 13, 17, 13,
++    18, 14, 17, 14, 19, 14, 18,
++    14, 19, 14, 20, 15, 20, 15,
++    21, 15, 20, 16, 21, 16,
++};
++
++
++#define FF_WMA3_HUFF_COEF1_SIZE 244
++#define FF_WMA3_HUFF_COEF1_MAXBITS 22
++static const uint32_t ff_wma3_coef1_huffcodes[FF_WMA3_HUFF_COEF1_SIZE] = {
++    0x0001E2, 0x00007F, 0x000000, 0x000002, 0x000008, 0x00000E, 0x000019,
++    0x00002F, 0x000037, 0x000060, 0x00006C, 0x000095, 0x0000C6, 0x0000F0,
++    0x00012E, 0x000189, 0x0001A5, 0x0001F8, 0x000253, 0x00030A, 0x000344,
++    0x00034D, 0x0003F2, 0x0004BD, 0x0005D7, 0x00062A, 0x00068B, 0x000693,
++    0x000797, 0x00097D, 0x000BAB, 0x000C52, 0x000C5E, 0x000D21, 0x000D20,
++    0x000F1A, 0x000FCE, 0x000FD1, 0x0012F1, 0x001759, 0x0018AC, 0x0018A7,
++    0x0018BF, 0x001A2B, 0x001E52, 0x001E50, 0x001E31, 0x001FB8, 0x0025E6,
++    0x0025E7, 0x002EB4, 0x002EB7, 0x003169, 0x00315B, 0x00317C, 0x00316C,
++    0x0034CA, 0x00348D, 0x003F40, 0x003CA2, 0x003F76, 0x004BC3, 0x004BE5,
++    0x003F73, 0x004BF8, 0x004BF9, 0x006131, 0x00628B, 0x006289, 0x0062DA,
++    0x00628A, 0x0062D4, 0x006997, 0x0062B4, 0x006918, 0x00794D, 0x007E7B,
++    0x007E87, 0x007EEA, 0x00794E, 0x00699D, 0x007967, 0x00699F, 0x0062DB,
++    0x007E7A, 0x007EEB, 0x00BAC0, 0x0097C9, 0x00C537, 0x00C5AB, 0x00D233,
++    0x00D338, 0x00BAC1, 0x00D23D, 0x012F91, 0x00D339, 0x00FDC8, 0x00D23C,
++    0x00FDDC, 0x00FDC9, 0x00FDDD, 0x00D33C, 0x000003, 0x000016, 0x00003E,
++    0x0000C3, 0x0001A1, 0x000347, 0x00062E, 0x000BAA, 0x000F2D, 0x001A2A,
++    0x001E58, 0x00309B, 0x003CA3, 0x005D6A, 0x00629A, 0x006996, 0x00794F,
++    0x007EE5, 0x00BAD7, 0x00C5AA, 0x00C5F4, 0x00FDDF, 0x00FDDE, 0x018A20,
++    0x018A6D, 0x01A67B, 0x01A464, 0x025F21, 0x01F9E2, 0x01F9E3, 0x00000A,
++    0x00003D, 0x000128, 0x0003C7, 0x000C24, 0x0018A3, 0x002EB1, 0x003CB2,
++    0x00691F, 0x007E79, 0x000013, 0x0000BB, 0x00034E, 0x000D14, 0x0025FD,
++    0x004BE7, 0x000024, 0x000188, 0x0007EF, 0x000035, 0x000308, 0x0012F2,
++    0x00005C, 0x0003F6, 0x0025E0, 0x00006D, 0x000698, 0x000096, 0x000C25,
++    0x0000C7, 0x000F1B, 0x0000F3, 0x0012FF, 0x000174, 0x001A66, 0x0001A0,
++    0x003099, 0x0001E4, 0x00316B, 0x000252, 0x003F31, 0x00030B, 0x004BE6,
++    0x000346, 0x0062FB, 0x00034F, 0x007966, 0x0003F5, 0x007E86, 0x0005D4,
++    0x00C511, 0x00062C, 0x00C5F5, 0x000692, 0x00F299, 0x000795, 0x00F298,
++    0x0007E9, 0x018A21, 0x00097E, 0x0175AD, 0x000C27, 0x01A67A, 0x000C57,
++    0x02EB59, 0x000D22, 0x0314D9, 0x000F19, 0x03F3C2, 0x000FCD, 0x0348CB,
++    0x0012F8, 0x04BE41, 0x0018A0, 0x03F3C1, 0x0018A1, 0x04BE40, 0x0018B7,
++    0x0629B0, 0x001A64, 0x0D2329, 0x001E30, 0x03F3C3, 0x001F9F, 0x0BAD62,
++    0x001F99, 0x0FCF00, 0x00309A, 0x0629B1, 0x002EB6, 0x175AC3, 0x00314C,
++    0x069195, 0x003168, 0x0BAD63, 0x00348E, 0x175AC1, 0x003F30, 0x07E781,
++    0x003F41, 0x0D2328, 0x003F42, 0x1F9E03, 0x004BC2, 0x175AC2, 0x003F74,
++    0x175AC0, 0x005D61, 0x3F3C05, 0x006130, 0x3F3C04, 0x0062B5,
++};
++
++static const uint8_t ff_wma3_coef1_huffbits[FF_WMA3_HUFF_COEF1_SIZE] = {
++     9,  7,  2,  3,  4,  4,  5,
++     6,  6,  7,  7,  8,  8,  8,
++     9,  9,  9,  9, 10, 10, 10,
++    10, 10, 11, 11, 11, 11, 11,
++    11, 12, 12, 12, 12, 12, 12,
++    12, 12, 12, 13, 13, 13, 13,
++    13, 13, 13, 13, 13, 13, 14,
++    14, 14, 14, 14, 14, 14, 14,
++    14, 14, 14, 14, 14, 15, 15,
++    14, 15, 15, 15, 15, 15, 15,
++    15, 15, 15, 15, 15, 15, 15,
++    15, 15, 15, 15, 15, 15, 15,
++    15, 15, 16, 16, 16, 16, 16,
++    16, 16, 16, 17, 16, 16, 16,
++    16, 16, 16, 16,  3,  5,  6,
++     8,  9, 10, 11, 12, 12, 13,
++    13, 14, 14, 15, 15, 15, 15,
++    15, 16, 16, 16, 16, 16, 17,
++    17, 17, 17, 18, 17, 17,  4,
++     6,  9, 10, 12, 13, 14, 14,
++    15, 15,  5,  8, 10, 12, 14,
++    15,  6,  9, 11,  6, 10, 13,
++     7, 10, 14,  7, 11,  8, 12,
++     8, 12,  8, 13,  9, 13,  9,
++    14,  9, 14, 10, 14, 10, 15,
++    10, 15, 10, 15, 10, 15, 11,
++    16, 11, 16, 11, 16, 11, 16,
++    11, 17, 12, 17, 12, 17, 12,
++    18, 12, 18, 12, 18, 12, 18,
++    13, 19, 13, 18, 13, 19, 13,
++    19, 13, 20, 13, 18, 13, 20,
++    13, 20, 14, 19, 14, 21, 14,
++    19, 14, 20, 14, 21, 14, 19,
++    14, 20, 14, 21, 15, 21, 14,
++    21, 15, 22, 15, 22, 15,
++};
++
++
++static const uint8_t ff_wma3_coef0_run[FF_WMA3_HUFF_COEF0_SIZE] = {
++      0,   0,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,
++     12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
++     26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
++     40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,
++     54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,
++     68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,
++     82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
++     96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
++    110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
++    124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
++    138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,   0,   1,
++      2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
++     16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
++     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,   0,   1,   2,   3,
++      4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,
++     18,  19,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   0,   1,
++      2,   3,   4,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
++      1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
++      1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
++      1,   0,   1,   0,   1,   0,
++};
++
++static const uint8_t ff_wma3_coef0_level[FF_WMA3_HUFF_COEF0_SIZE] = {
++      0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
++      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,
++      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
++      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
++      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   3,   3,   3,   3,
++      3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
++      3,   3,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   5,   5,
++      5,   5,   5,   6,   6,   7,   7,   8,   8,   9,   9,  10,  10,  11,
++     11,  12,  12,  13,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,
++     18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  23,  24,  24,  25,
++     25,  26,  26,  27,  27,  28,
++};
++
++
++static const uint8_t ff_wma3_coef1_run[FF_WMA3_HUFF_COEF1_SIZE] = {
++     0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
++    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
++    34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
++    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
++    70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
++    88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,  0,  1,  2,  3,  4,  5,
++     6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
++    24, 25, 26, 27, 28, 29,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,
++     2,  3,  4,  5,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  0,  1,  0,
++     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
++     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
++     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
++     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
++     1,  0,  1,  0,  1,  0,  1,  0,  0,  0,
++};
++
++static const uint8_t ff_wma3_coef1_level[FF_WMA3_HUFF_COEF1_SIZE] = {
++     0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
++     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
++     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
++     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
++     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
++     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,
++     2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
++     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,
++     4,  4,  4,  4,  5,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  9,  9, 10,
++    10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19,
++    19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28,
++    28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37,
++    37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46,
++    46, 47, 47, 48, 48, 49, 49, 50, 51, 52,
++};
++/** @} */
++
++
++/**
++ * @name huffman and vector lookup tables for vector-coded coefficients
++ * @{
++ */
++#define FF_WMA3_HUFF_VEC4_SIZE 127
++#define FF_WMA3_HUFF_VEC4_MAXBITS 14
++static const uint32_t ff_wma3_vec4_huffcodes[FF_WMA3_HUFF_VEC4_SIZE] = {
++    0x0019, 0x0027, 0x00F2, 0x03BA, 0x0930, 0x1267, 0x0031, 0x0030,
++    0x0097, 0x0221, 0x058B, 0x0124, 0x00EB, 0x01D4, 0x03D8, 0x0584,
++    0x0364, 0x045F, 0x0F66, 0x0931, 0x24CD, 0x002F, 0x0039, 0x00E8,
++    0x02C3, 0x078A, 0x0037, 0x0029, 0x0084, 0x01B1, 0x00ED, 0x0086,
++    0x00F9, 0x03AB, 0x01EB, 0x08BC, 0x011E, 0x00F3, 0x0220, 0x058A,
++    0x00EC, 0x008E, 0x012B, 0x01EA, 0x0119, 0x04B0, 0x04B1, 0x03B8,
++    0x0691, 0x0365, 0x01ED, 0x049A, 0x0EA9, 0x0EA8, 0x08BD, 0x24CC,
++    0x0026, 0x0035, 0x00DB, 0x02C4, 0x07B2, 0x0038, 0x002B, 0x007F,
++    0x01B3, 0x00F4, 0x0091, 0x0116, 0x03BB, 0x0215, 0x0932, 0x002D,
++    0x002A, 0x008A, 0x01DE, 0x0028, 0x0020, 0x005C, 0x0090, 0x0068,
++    0x01EE, 0x00E9, 0x008D, 0x012A, 0x0087, 0x005D, 0x0118, 0x0349,
++    0x01EF, 0x01E3, 0x08B9, 0x00F0, 0x00D3, 0x0214, 0x049B, 0x00DA,
++    0x0089, 0x0125, 0x0217, 0x012D, 0x0690, 0x0094, 0x007D, 0x011F,
++    0x007E, 0x0059, 0x0127, 0x01A5, 0x0111, 0x00F8, 0x045D, 0x03B9,
++    0x0259, 0x0580, 0x02C1, 0x01DF, 0x0585, 0x0216, 0x0163, 0x01B0,
++    0x03C4, 0x08B8, 0x078B, 0x0755, 0x0581, 0x0F67, 0x0000,
++};
++
++static const uint8_t ff_wma3_vec4_huffbits[FF_WMA3_HUFF_VEC4_SIZE] = {
++     5,  6,  8, 10, 12, 13,  6,  6,
++     8, 10, 11,  9,  8,  9, 10, 11,
++    10, 11, 12, 12, 14,  6,  6,  8,
++    10, 11,  6,  6,  8,  9,  8,  8,
++     8, 10,  9, 12,  9,  8, 10, 11,
++     8,  8,  9,  9,  9, 11, 11, 10,
++    11, 10,  9, 11, 12, 12, 12, 14,
++     6,  6,  8, 10, 11,  6,  6,  7,
++     9,  8,  8,  9, 10, 10, 12,  6,
++     6,  8,  9,  6,  6,  7,  8,  7,
++     9,  8,  8,  9,  8,  7,  9, 10,
++     9,  9, 12,  8,  8, 10, 11,  8,
++     8,  9, 10,  9, 11,  8,  7,  9,
++     7,  7,  9,  9,  9,  8, 11, 10,
++    10, 11, 10,  9, 11, 10,  9,  9,
++    10, 12, 11, 11, 11, 12,  1,
++};
++
++
++#define FF_WMA3_HUFF_VEC2_SIZE 137
++#define FF_WMA3_HUFF_VEC2_MAXBITS 12
++static const uint32_t ff_wma3_vec2_huffcodes[FF_WMA3_HUFF_VEC2_SIZE] = {
++    0x055, 0x01C, 0x01A, 0x02B, 0x028, 0x067, 0x08B, 0x039,
++    0x170, 0x10D, 0x2A5, 0x047, 0x464, 0x697, 0x523, 0x8CB,
++    0x01B, 0x00E, 0x000, 0x010, 0x012, 0x036, 0x048, 0x04C,
++    0x0C2, 0x09B, 0x171, 0x03B, 0x224, 0x34A, 0x2D6, 0x019,
++    0x00F, 0x002, 0x014, 0x017, 0x006, 0x05D, 0x054, 0x0C7,
++    0x0B4, 0x192, 0x10E, 0x233, 0x043, 0x02C, 0x00F, 0x013,
++    0x006, 0x02F, 0x02C, 0x068, 0x077, 0x0DF, 0x111, 0x1A4,
++    0x16A, 0x2A4, 0x027, 0x011, 0x018, 0x02D, 0x00F, 0x04A,
++    0x040, 0x097, 0x01F, 0x11B, 0x022, 0x16D, 0x066, 0x035,
++    0x005, 0x02B, 0x049, 0x009, 0x075, 0x0CB, 0x0AA, 0x187,
++    0x106, 0x08A, 0x047, 0x060, 0x06E, 0x01D, 0x074, 0x0C4,
++    0x01E, 0x118, 0x1A7, 0x038, 0x042, 0x053, 0x076, 0x0A8,
++    0x0CA, 0x082, 0x110, 0x18D, 0x12D, 0x0B9, 0x0C8, 0x0DE,
++    0x01C, 0x0AB, 0x113, 0x18C, 0x10F, 0x09A, 0x0A5, 0x0B7,
++    0x11A, 0x186, 0x1A6, 0x259, 0x153, 0x18A, 0x193, 0x020,
++    0x10C, 0x046, 0x03A, 0x107, 0x149, 0x16C, 0x2D7, 0x225,
++    0x258, 0x316, 0x696, 0x317, 0x042, 0x522, 0x290, 0x8CA,
++    0x001,
++};
++
++static const uint8_t ff_wma3_vec2_huffbits[FF_WMA3_HUFF_VEC2_SIZE] = {
++     7,  6,  6,  6,  7,  7,  8,  9,
++     9, 10, 10, 11, 11, 11, 12, 12,
++     6,  4,  5,  5,  6,  6,  7,  8,
++     8,  9,  9, 10, 10, 10, 11,  6,
++     4,  5,  5,  6,  7,  7,  8,  8,
++     9,  9, 10, 10, 11,  6,  5,  5,
++     6,  6,  7,  7,  8,  8,  9,  9,
++    10, 10,  7,  6,  6,  6,  7,  7,
++     8,  8,  9,  9, 10, 10,  7,  6,
++     7,  7,  7,  8,  8,  8,  9,  9,
++    10,  8,  7,  7,  7,  8,  8,  8,
++     9,  9,  9,  9,  8,  8,  8,  8,
++     8,  9,  9,  9,  9,  8,  8,  8,
++     9,  9,  9,  9, 10,  9,  9,  9,
++     9,  9,  9, 10,  9,  9,  9, 10,
++    10, 11, 10, 10, 10, 10, 11, 10,
++    10, 10, 11, 10, 11, 12, 11, 12,
++     3,
++};
++
++
++#define FF_WMA3_HUFF_VEC1_SIZE 101
++#define FF_WMA3_HUFF_VEC1_MAXBITS 11
++static const uint32_t ff_wma3_vec1_huffcodes[FF_WMA3_HUFF_VEC1_SIZE] = {
++    0x01A, 0x003, 0x017, 0x010, 0x00C, 0x009, 0x005, 0x000,
++    0x00D, 0x00A, 0x009, 0x00C, 0x00F, 0x002, 0x004, 0x007,
++    0x00B, 0x00F, 0x01C, 0x006, 0x010, 0x015, 0x01C, 0x022,
++    0x03B, 0x00E, 0x019, 0x023, 0x034, 0x036, 0x03A, 0x047,
++    0x008, 0x00A, 0x01E, 0x031, 0x037, 0x050, 0x053, 0x06B,
++    0x06F, 0x08C, 0x0E8, 0x0EA, 0x0EB, 0x016, 0x03E, 0x03F,
++    0x06C, 0x089, 0x08A, 0x0A3, 0x0A4, 0x0D4, 0x0DD, 0x0EC,
++    0x0EE, 0x11A, 0x1D2, 0x024, 0x025, 0x02E, 0x027, 0x0C2,
++    0x0C0, 0x0DA, 0x0DB, 0x111, 0x144, 0x116, 0x14A, 0x145,
++    0x1B8, 0x1AB, 0x1DA, 0x1DE, 0x1DB, 0x1DF, 0x236, 0x237,
++    0x3A6, 0x3A7, 0x04D, 0x04C, 0x05E, 0x05F, 0x183, 0x182,
++    0x186, 0x221, 0x187, 0x220, 0x22E, 0x22F, 0x296, 0x354,
++    0x297, 0x355, 0x372, 0x373, 0x016,
++};
++
++static const uint8_t ff_wma3_vec1_huffbits[FF_WMA3_HUFF_VEC1_SIZE] = {
++     7,  6,  5,  5,  5,  5,  5,  5,
++     4,  4,  4,  4,  4,  5,  5,  5,
++     5,  5,  5,  6,  6,  6,  6,  6,
++     6,  7,  7,  7,  7,  7,  7,  7,
++     8,  8,  8,  8,  8,  8,  8,  8,
++     8,  8,  8,  8,  8,  9,  9,  9,
++     9,  9,  9,  9,  9,  9,  9,  9,
++     9,  9,  9, 10, 10, 10, 10, 10,
++    10, 10, 10, 10, 10, 10, 10, 10,
++    10, 10, 10, 10, 10, 10, 10, 10,
++    10, 10, 11, 11, 11, 11, 11, 11,
++    11, 11, 11, 11, 11, 11, 11, 11,
++    11, 11, 11, 11,  5,
++};
++
++
++static const uint16_t ff_wma3_symbol_to_vec4[FF_WMA3_HUFF_VEC4_SIZE] = {
++        0,    1,      2,     3,     4,     5,    16,    17,    18,    19,
++       20,   32,     33,    34,    35,    48,    49,    50,    64,    65,
++       80,   256,   257,   258,   259,   260,   272,   273,   274,   275,
++      288,   289,   290,   304,   305,   320,   512,   513,   514,   515,
++      528,   529,   530,   544,   545,   560,   768,   769,   770,   784,
++      785,   800,  1024,  1025,  1040,  1280,  4096,  4097,  4098,  4099,
++     4100,  4112,  4113,  4114,  4115,  4128,  4129,  4130,  4144,  4145,
++     4160,  4352,  4353,  4354,  4355,  4368,  4369,  4370,  4384,  4385,
++     4400,  4608,  4609,  4610,  4624,  4625,  4640,  4864,  4865,  4880,
++     5120,  8192,  8193,  8194,  8195,  8208,  8209,  8210,  8224,  8225,
++     8240,  8448,  8449,  8450,  8464,  8465,  8480,  8704,  8705,  8720,
++     8960, 12288, 12289, 12290, 12304, 12305, 12320, 12544, 12545, 12560,
++    12800, 16384, 16385, 16400, 16640, 20480,     0,
++};
++
++
++static const uint8_t ff_wma3_symbol_to_vec2[FF_WMA3_HUFF_VEC2_SIZE] = {
++      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
++     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
++     30,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,
++     48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  64,  65,
++     66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  80,  81,  82,  83,  84,
++     85,  86,  87,  88,  89,  90,  96,  97,  98,  99, 100, 101, 102, 103, 104,
++    105, 112, 113, 114, 115, 116, 117, 118, 119, 120, 128, 129, 130, 131, 132,
++    133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 160, 161, 162, 163, 164,
++    165, 176, 177, 178, 179, 180, 192, 193, 194, 195, 208, 209, 210, 224, 225,
++    240,   0,
++};
++/** @} */
++
++
++/**
++ * @brief decorrelation matrix for multichannel streams
++ **/
++static const float ff_wma3_default_decorrelation_matrices[] = {
++    1.000000,  0.707031, -0.707031,  0.707031,  0.707031,  0.578125,  0.707031,
++    0.410156,  0.578125, -0.707031,  0.410156,  0.578125,  0.000000, -0.816406,
++    0.500000,  0.652344,  0.500000,  0.269531,  0.500000,  0.269531, -0.500000,
++   -0.652344,  0.500000, -0.269531, -0.500000,  0.652344,  0.500000, -0.652344,
++    0.500000, -0.269531,  0.445312,  0.601562,  0.511719,  0.371094,  0.195312,
++    0.445312,  0.371094, -0.195312, -0.601562, -0.511719,  0.445312,  0.000000,
++   -0.632812,  0.000000,  0.632812,  0.445312, -0.371094, -0.195312,  0.601562,
++   -0.511719,  0.445312, -0.601562,  0.511719, -0.371094,  0.195312,  0.410156,
++    0.558594,  0.500000,  0.410156,  0.289062,  0.148438,  0.410156,  0.410156,
++    0.000000, -0.410156, -0.578125, -0.410156,  0.410156,  0.148438, -0.500000,
++   -0.410156,  0.289062,  0.558594,  0.410156, -0.148438, -0.500000,  0.410156,
++    0.289062, -0.558594,  0.410156, -0.410156,  0.000000,  0.410156, -0.578125,
++    0.410156,  0.410156, -0.558594,  0.500000, -0.410156,  0.289062, -0.148438,
++};
++
++#endif /* AVCODEC_WMA3DATA_H */
+diff -urNad svn~/libavcodec/wma3dec.c svn/libavcodec/wma3dec.c
+--- svn~/libavcodec/wma3dec.c	1970-01-01 01:00:00.000000000 +0100
++++ svn/libavcodec/wma3dec.c	2009-05-28 10:52:37.000000000 +0200
+@@ -0,0 +1,1680 @@
++/*
++ * WMA 9/3/PRO compatible decoder
++ * Copyright (c) 2007 Baptiste Coudurier, Benjamin Larsson, Ulion
++ * Copyright (c) 2008 - 2009 Sascha Sommer, Benjamin Larsson
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++/**
++ * @file  libavcodec/wma3dec.c
++ * @brief wmapro decoder implementation
++ */
++
++#include "avcodec.h"
++#include "get_bits.h"
++#include "wma3.h"
++
++#define VLCBITS            9
++#define SCALEVLCBITS       8
++
++/**
++ *@brief helper function to print the most important members of the context
++ *@param s context
++ */
++static void wma_dump_context(WMA3DecodeContext *s)
++{
++#define PRINT(a,b) av_log(s->avctx,AV_LOG_DEBUG," %s = %d\n", a, b);
++#define PRINT_HEX(a,b) av_log(s->avctx,AV_LOG_DEBUG," %s = %x\n", a, b);
++
++    PRINT("ed sample bit depth",s->sample_bit_depth);
++    PRINT_HEX("ed decode flags",s->decode_flags);
++    PRINT("samples per frame",s->samples_per_frame);
++    PRINT("log2 frame size",s->log2_frame_size);
++    PRINT("max num subframes",s->max_num_subframes);
++    PRINT("len prefix",s->len_prefix);
++    PRINT("num channels",s->num_channels);
++    PRINT("lossless",s->lossless);
++}
++
++/**
++ *@brief Get the samples per frame for this stream.
++ *@param sample_rate output sample_rate
++ *@param decode_flags codec compression features
++ *@return number of output samples per frame
++ */
++static int wma_get_samples_per_frame(int sample_rate, unsigned int decode_flags)
++{
++
++    int samples_per_frame;
++    int tmp;
++
++    if (sample_rate <= 16000)
++        samples_per_frame = 512;
++    else if (sample_rate <= 22050)
++        samples_per_frame = 1024;
++    else if (sample_rate <= 48000)
++        samples_per_frame = 2048;
++    else if (sample_rate <= 96000)
++        samples_per_frame = 4096;
++    else
++        samples_per_frame = 8192;
++
++    /* WMA voice code  if (decode_flags & 0x800) {
++        tmp = ((decode_flags & 6) >> 1) | ((decode_flags & 0x600) >> 7);
++        samples_per_frame = (tmp+1)*160;
++    } else { */
++
++    tmp = decode_flags & 0x6;
++    if (tmp == 0x2)
++        samples_per_frame <<= 1;
++    else if (tmp == 0x4)
++        samples_per_frame >>= 1;
++    else if (tmp == 0x6)
++        samples_per_frame >>= 2;
++
++    return samples_per_frame;
++}
++
++/**
++ *@brief Uninitialize the decoder and free all resources.
++ *@param avctx codec context
++ *@return 0 on success, < 0 otherwise
++ */
++static av_cold int wma_decode_end(AVCodecContext *avctx)
++{
++    WMA3DecodeContext *s = avctx->priv_data;
++    int i;
++
++    av_free(s->num_sfb);
++    av_free(s->sfb_offsets);
++    av_free(s->subwoofer_cutoffs);
++    av_free(s->sf_offsets);
++
++    if(s->def_decorrelation_mat){
++        for(i=1;i<=s->num_channels;i++)
++            av_free(s->def_decorrelation_mat[i]);
++        av_free(s->def_decorrelation_mat);
++    }
++
++    free_vlc(&s->sf_vlc);
++    free_vlc(&s->sf_rl_vlc);
++    free_vlc(&s->coef_vlc[0]);
++    free_vlc(&s->coef_vlc[1]);
++    free_vlc(&s->vec4_vlc);
++    free_vlc(&s->vec2_vlc);
++    free_vlc(&s->vec1_vlc);
++
++    for(i=0 ; i<BLOCK_NB_SIZES ; i++)
++        ff_mdct_end(&s->mdct_ctx[i]);
++
++    return 0;
++}
++
++/**
++ *@brief Initialize the decoder.
++ *@param avctx codec context
++ *@return 0 on success, -1 otherwise
++ */
++static av_cold int wma_decode_init(AVCodecContext *avctx)
++{
++    WMA3DecodeContext *s = avctx->priv_data;
++    uint8_t *edata_ptr = avctx->extradata;
++    int* sfb_offsets;
++    unsigned int channel_mask;
++    int i;
++
++    s->avctx = avctx;
++    dsputil_init(&s->dsp, avctx);
++
++    /* FIXME: is this really the right thing to do for 24 bits? */
++    s->sample_bit_depth = 16; // avctx->bits_per_sample;
++    if (avctx->extradata_size >= 18) {
++        s->decode_flags     = AV_RL16(edata_ptr+14);
++        channel_mask    = AV_RL32(edata_ptr+2);
++//        s->sample_bit_depth = AV_RL16(edata_ptr);
++
++        /** dump the extradata */
++        for (i=0 ; i<avctx->extradata_size ; i++)
++            av_log(avctx, AV_LOG_DEBUG, "[%x] ",avctx->extradata[i]);
++        av_log(avctx, AV_LOG_DEBUG, "\n");
++
++    } else {
++        av_log(avctx, AV_LOG_ERROR, "Unknown extradata size %d.\n",
++                      avctx->extradata_size);
++        return -1;
++    }
++
++    /** generic init */
++    s->log2_frame_size = av_log2(avctx->block_align*8)+1;
++
++    /** frame info */
++    s->skip_frame = 1; /** skip first frame */
++    s->packet_loss = 1;
++    s->len_prefix = (s->decode_flags & 0x40) >> 6;
++
++    if(!s->len_prefix){
++         av_log(avctx, AV_LOG_ERROR, "file has no length prefix, please report\n");
++         return -1;
++    }
++
++    /** get frame len */
++    s->samples_per_frame = wma_get_samples_per_frame(avctx->sample_rate,
++                                                 s->decode_flags);
++
++    /** init previous block len */
++    for(i=0;i<avctx->channels;i++)
++        s->channel[i].prev_block_len = s->samples_per_frame;
++
++    /** subframe info */
++    s->max_num_subframes = 1 << ((s->decode_flags & 0x38) >> 3);
++    s->num_possible_block_sizes = av_log2(s->max_num_subframes) + 1;
++    s->allow_subframes = s->max_num_subframes > 1;
++    s->min_samples_per_subframe = s->samples_per_frame / s->max_num_subframes;
++    s->dynamic_range_compression = (s->decode_flags & 0x80) >> 7;
++
++    if(s->max_num_subframes > MAX_SUBFRAMES){
++        av_log(avctx, AV_LOG_ERROR, "invalid number of subframes %i\n",
++                      s->max_num_subframes);
++        return -1;
++    }
++
++    s->num_channels = avctx->channels;
++
++    /** extract lfe channel position */
++    s->lfe_channel = -1;
++
++    if(channel_mask & 8){
++        unsigned int mask = 1;
++        for(i=0;i<32;i++){
++            if(channel_mask & mask)
++                ++s->lfe_channel;
++            if(mask & 8)
++                break;
++            mask <<= 1;
++        }
++    }
++
++    if(s->num_channels < 0 || s->num_channels > MAX_CHANNELS){
++        av_log(avctx, AV_LOG_ERROR, "invalid number of channels %i\n",
++                      s->num_channels);
++        return -1;
++    }
++
++    init_vlc(&s->sf_vlc, SCALEVLCBITS, FF_WMA3_HUFF_SCALE_SIZE,
++                 ff_wma3_scale_huffbits, 1, 1,
++                 ff_wma3_scale_huffcodes, 4, 4, 0);
++
++    init_vlc(&s->sf_rl_vlc, VLCBITS, FF_WMA3_HUFF_SCALE_RL_SIZE,
++                 ff_wma3_scale_rl_huffbits, 1, 1,
++                 ff_wma3_scale_rl_huffcodes, 4, 4, 0);
++
++    init_vlc(&s->coef_vlc[0], VLCBITS, FF_WMA3_HUFF_COEF0_SIZE,
++                 ff_wma3_coef0_huffbits, 1, 1,
++                 ff_wma3_coef0_huffcodes, 4, 4, 0);
++
++    s->coef_max[0] = ((FF_WMA3_HUFF_COEF0_MAXBITS+VLCBITS-1)/VLCBITS);
++
++    init_vlc(&s->coef_vlc[1], VLCBITS, FF_WMA3_HUFF_COEF1_SIZE,
++                 ff_wma3_coef1_huffbits, 1, 1,
++                 ff_wma3_coef1_huffcodes, 4, 4, 0);
++
++    s->coef_max[1] = ((FF_WMA3_HUFF_COEF1_MAXBITS+VLCBITS-1)/VLCBITS);
++
++    init_vlc(&s->vec4_vlc, VLCBITS, FF_WMA3_HUFF_VEC4_SIZE,
++                 ff_wma3_vec4_huffbits, 1, 1,
++                 ff_wma3_vec4_huffcodes, 4, 4, 0);
++
++    init_vlc(&s->vec2_vlc, VLCBITS, FF_WMA3_HUFF_VEC2_SIZE,
++                 ff_wma3_vec2_huffbits, 1, 1,
++                 ff_wma3_vec2_huffcodes, 4, 4, 0);
++
++    init_vlc(&s->vec1_vlc, VLCBITS, FF_WMA3_HUFF_VEC1_SIZE,
++                 ff_wma3_vec1_huffbits, 1, 1,
++                 ff_wma3_vec1_huffcodes, 4, 4, 0);
++
++    s->num_sfb = av_mallocz(sizeof(int)*s->num_possible_block_sizes);
++    s->sfb_offsets = av_mallocz(MAX_BANDS * sizeof(int) *s->num_possible_block_sizes);
++    s->subwoofer_cutoffs = av_mallocz(sizeof(int)*s->num_possible_block_sizes);
++    s->sf_offsets = av_mallocz(s->num_possible_block_sizes *
++                               s->num_possible_block_sizes * MAX_BANDS * sizeof(int));
++
++    if(!s->num_sfb || !s->sfb_offsets || !s->subwoofer_cutoffs || !s->sf_offsets){
++        av_log(avctx, AV_LOG_ERROR, "failed to allocate scale factor offset tables\n");
++        wma_decode_end(avctx);
++        return -1;
++    }
++
++    /** calculate number of scale factor bands and their offsets
++        for every possible block size */
++    sfb_offsets = s->sfb_offsets;
++
++    for(i=0;i<s->num_possible_block_sizes;i++){
++        int subframe_len = s->samples_per_frame / (1 << i);
++        int x;
++        int band = 1;
++
++        sfb_offsets[0] = 0;
++
++        for(x=0;x < MAX_BANDS-1 && sfb_offsets[band-1] < subframe_len;x++){
++            int offset = (subframe_len * 2 * ff_wma3_critical_freq[x]) / s->avctx->sample_rate + 2;
++            offset -= offset % 4;
++            if ( offset > sfb_offsets[band - 1] ){
++                sfb_offsets[band] = offset;
++                ++band;
++            }
++        }
++        sfb_offsets[band - 1] = subframe_len;
++        s->num_sfb[i] = band - 1;
++        sfb_offsets += MAX_BANDS;
++    }
++
++
++    /** Scale factors can be shared between blocks of different size
++        as every block has a different scale factor band layout.
++        The matrix sf_offsets is needed to find the correct scale factor.
++     */
++
++    for(i=0;i<s->num_possible_block_sizes;i++){
++        int b;
++        for(b=0;b< s->num_sfb[i];b++){
++            int x;
++            int offset = ((s->sfb_offsets[MAX_BANDS * i + b]
++                          + s->sfb_offsets[MAX_BANDS * i + b + 1] - 1)<<i)/2;
++            for(x=0;x<s->num_possible_block_sizes;x++){
++                int v = 0;
++                while(s->sfb_offsets[MAX_BANDS * x + v +1] << x < offset)
++                    ++v;
++                s->sf_offsets[  i * s->num_possible_block_sizes * MAX_BANDS
++                              + x * MAX_BANDS + b] = v;
++            }
++        }
++    }
++
++    /** init MDCT, FIXME: only init needed sizes */
++    for(i = 0; i < BLOCK_NB_SIZES; i++)
++        ff_mdct_init(&s->mdct_ctx[i], BLOCK_MIN_BITS+1+i, 1, 1.0 / (1<<(BLOCK_MIN_BITS+i-1)));
++
++    /** init MDCT windows: simple sinus window */
++    for(i=0 ; i<BLOCK_NB_SIZES ; i++) {
++        int n;
++        n = 1 << (BLOCK_MAX_BITS - i);
++        ff_sine_window_init(ff_sine_windows[BLOCK_MAX_BITS - i - 7], n);
++        s->windows[BLOCK_NB_SIZES-i-1] = ff_sine_windows[BLOCK_MAX_BITS - i - 7];
++    }
++
++    /** calculate subwoofer cutoff values */
++
++    for(i=0;i< s->num_possible_block_sizes;i++){
++        int block_size = s->samples_per_frame / (1 << i);
++        int cutoff = ceil(block_size * 440.0 / (double)s->avctx->sample_rate + 0.5);
++        if(cutoff < 4)
++            cutoff = 4;
++        if(cutoff > block_size)
++            cutoff = block_size;
++        s->subwoofer_cutoffs[i] = cutoff;
++    }
++
++    /** set up decorrelation matrixes */
++    s->def_decorrelation_mat = av_mallocz(sizeof(float*) * (s->num_channels + 1));
++    if(!s->def_decorrelation_mat){
++        av_log(avctx, AV_LOG_ERROR, "failed to allocate decorrelation matrix\n");
++        wma_decode_end(avctx);
++        return -1;
++    }
++
++    s->def_decorrelation_mat[0] = 0;
++    for(i=1;i<=s->num_channels;i++){
++        const float* tab = ff_wma3_default_decorrelation_matrices;
++        s->def_decorrelation_mat[i] = av_mallocz(sizeof(float*) * i);
++        if(!s->def_decorrelation_mat[i]){
++            av_log(avctx, AV_LOG_ERROR, "failed to set up decorrelation matrix\n");
++            wma_decode_end(avctx);
++            return -1;
++        }
++        switch(i){
++            case 1:
++                s->def_decorrelation_mat[i][0] = &tab[0];
++                break;
++            case 2:
++                s->def_decorrelation_mat[i][0] = &tab[1];
++                s->def_decorrelation_mat[i][1] = &tab[3];
++                break;
++            case 3:
++                s->def_decorrelation_mat[i][0] = &tab[5];
++                s->def_decorrelation_mat[i][1] = &tab[8];
++                s->def_decorrelation_mat[i][2] = &tab[11];
++                break;
++            case 4:
++                s->def_decorrelation_mat[i][0] = &tab[14];
++                s->def_decorrelation_mat[i][1] = &tab[18];
++                s->def_decorrelation_mat[i][2] = &tab[22];
++                s->def_decorrelation_mat[i][3] = &tab[26];
++                break;
++            case 5:
++                s->def_decorrelation_mat[i][0] = &tab[30];
++                s->def_decorrelation_mat[i][1] = &tab[35];
++                s->def_decorrelation_mat[i][2] = &tab[40];
++                s->def_decorrelation_mat[i][3] = &tab[45];
++                s->def_decorrelation_mat[i][4] = &tab[50];
++                break;
++            case 6:
++                s->def_decorrelation_mat[i][0] = &tab[55];
++                s->def_decorrelation_mat[i][1] = &tab[61];
++                s->def_decorrelation_mat[i][2] = &tab[67];
++                s->def_decorrelation_mat[i][3] = &tab[73];
++                s->def_decorrelation_mat[i][4] = &tab[79];
++                s->def_decorrelation_mat[i][5] = &tab[85];
++                break;
++        }
++    }
++
++    wma_dump_context(s);
++    avctx->channel_layout = channel_mask;
++    return 0;
++}
++
++/**
++ *@brief Decode how the data in the frame is split into subframes.
++ *       Every WMA frame contains the encoded data for a fixed number of
++ *       samples per channel. The data for every channel might be split
++ *       into several subframes. This function will reconstruct the list of
++ *       subframes for every channel.
++ *
++ *       If the subframes are not evenly split, the algorithm estimates the
++ *       channels with the lowest number of total samples.
++ *       Afterwards, for each of these channels a bit is read from the
++ *       bitstream that indicates if the channel contains a frame with the
++ *       next subframe size that is going to be read from the bitstream or not.
++ *       If a channel contains such a subframe, the subframe size gets added to
++ *       the channel's subframe list.
++ *       The algorithm repeats these steps until the frame is properly divided
++ *       between the individual channels.
++ *
++ *@param s context
++ *@return 0 on success, < 0 in case of an error
++ */
++static int wma_decode_tilehdr(WMA3DecodeContext *s)
++{
++    int c;
++    int missing_samples = s->num_channels * s->samples_per_frame;
++
++    /* should never consume more than 3073 bits (256 iterations for the
++     * while loop when always the minimum amount of 128 samples is substracted
++     * from missing samples in the 8 channel case)
++     * 1 + BLOCK_MAX_SIZE * MAX_CHANNELS / BLOCK_MIN_SIZE * (MAX_CHANNELS  + 4)
++     */
++
++    /** reset tiling information */
++    for(c=0;c<s->num_channels;c++){
++        s->channel[c].num_subframes = 0;
++        s->channel[c].channel_len = 0;
++    }
++
++    /** handle the easy case with one constant-sized subframe per channel */
++    if(s->max_num_subframes == 1){
++        for(c=0;c<s->num_channels;c++){
++            s->channel[c].num_subframes = 1;
++            s->channel[c].subframe_len[0] = s->samples_per_frame;
++            s->channel[c].channel_len = 0;
++        }
++    }else{ /** subframe length and number of subframes is not constant */
++        int subframe_len_bits = 0;     /** bits needed for the subframe length */
++        int subframe_len_zero_bit = 0; /** first bit indicates if length is zero */
++        int fixed_channel_layout;      /** all channels have the same subframe layout */
++
++        fixed_channel_layout = get_bits1(&s->gb);
++
++        /** calculate subframe len bits */
++        if(s->lossless)
++            subframe_len_bits = av_log2(s->max_num_subframes - 1) + 1;
++        else if(s->max_num_subframes == 16){
++            subframe_len_zero_bit = 1;
++            subframe_len_bits = 3;
++        }else
++            subframe_len_bits = av_log2(av_log2(s->max_num_subframes)) + 1;
++
++        /** loop until the frame data is split between the subframes */
++        while(missing_samples > 0){
++            unsigned int channel_mask = 0;
++            int min_channel_len = s->samples_per_frame;
++            int read_channel_mask = 1;
++            int channels_for_cur_subframe = 0;
++            int subframe_len;
++
++            if(fixed_channel_layout){
++                read_channel_mask = 0;
++                channels_for_cur_subframe = s->num_channels;
++                min_channel_len = s->channel[0].channel_len;
++            }else{
++                /** find channels with the smallest overall length */
++                for(c=0;c<s->num_channels;c++){
++                    if(s->channel[c].channel_len <= min_channel_len){
++                        if(s->channel[c].channel_len < min_channel_len){
++                            channels_for_cur_subframe = 0;
++                            min_channel_len = s->channel[c].channel_len;
++                        }
++                        ++channels_for_cur_subframe;
++                    }
++                }
++
++                if(channels_for_cur_subframe == 1 ||
++                  s->min_samples_per_subframe * channels_for_cur_subframe == missing_samples)
++                    read_channel_mask = 0;
++            }
++
++            /** For every channel with the minimum length, 1 bit
++                might be transmitted that informs us if the channel
++                contains a subframe with the next subframe_len. */
++            if(read_channel_mask){
++                channel_mask = get_bits(&s->gb,channels_for_cur_subframe);
++                if(!channel_mask){
++                    av_log(s->avctx, AV_LOG_ERROR,
++                        "broken frame: zero frames for subframe_len\n");
++                    return -1;
++                }
++            }
++
++            /** if we have the choice get next subframe length from the bitstream */
++            if(s->min_samples_per_subframe * channels_for_cur_subframe != missing_samples){
++                int log2_subframe_len = 0;
++                /* 1 bit indicates if the subframe length is zero */
++                if(subframe_len_zero_bit){
++                    if(get_bits1(&s->gb)){
++                        log2_subframe_len =
++                            get_bits(&s->gb,subframe_len_bits-1);
++                        ++log2_subframe_len;
++                    }
++                }else
++                    log2_subframe_len = get_bits(&s->gb,subframe_len_bits);
++
++                if(s->lossless){
++                    subframe_len =
++                        s->samples_per_frame / s->max_num_subframes;
++                    subframe_len *= log2_subframe_len + 1;
++                }else
++                    subframe_len =
++                        s->samples_per_frame / (1 << log2_subframe_len);
++
++                /** sanity check the length */
++                if(subframe_len < s->min_samples_per_subframe
++                    || subframe_len > s->samples_per_frame){
++                    av_log(s->avctx, AV_LOG_ERROR,
++                        "broken frame: subframe_len %i\n", subframe_len);
++                    return -1;
++                }
++            }else
++                subframe_len = s->min_samples_per_subframe;
++
++            for(c=0; c<s->num_channels;c++){
++                WMA3ChannelCtx* chan = &s->channel[c];
++
++                /** add subframes to the individual channels */
++                if(min_channel_len == chan->channel_len){
++                    --channels_for_cur_subframe;
++                    if(!read_channel_mask || channel_mask & (1<<channels_for_cur_subframe)){
++                        if(chan->num_subframes > 31){
++                            av_log(s->avctx, AV_LOG_ERROR,
++                                    "broken frame: num subframes > 31\n");
++                            return -1;
++                        }
++                        chan->subframe_len[chan->num_subframes] = subframe_len;
++                        chan->channel_len += subframe_len;
++                        missing_samples -= subframe_len;
++                        ++chan->num_subframes;
++                        if(missing_samples < 0
++                            || chan->channel_len > s->samples_per_frame){
++                            av_log(s->avctx, AV_LOG_ERROR,"broken frame: "
++                                    "channel len > samples_per_frame\n");
++                            return -1;
++                        }
++                    }
++                }
++            }
++        }
++    }
++
++    for(c=0;c<s->num_channels;c++){
++        int i;
++        int offset = 0;
++        for(i=0;i<s->channel[c].num_subframes;i++){
++            av_log(s->avctx, AV_LOG_DEBUG,"frame[%i] channel[%i] subframe[%i]"
++                   " len %i\n",s->frame_num,c,i,s->channel[c].subframe_len[i]);
++            s->channel[c].subframe_offset[i] = offset;
++            offset += s->channel[c].subframe_len[i];
++        }
++    }
++
++    return 0;
++}
++
++/**
++ *@brief Decode channel transformation parameters
++ *@param s codec context
++ *@return 0 in case of bitstream errors, 1 on success
++ */
++static int wma_decode_channel_transform(WMA3DecodeContext* s)
++{
++    int i;
++    /* should never consume more than 1921 bits for the 8 channel case
++     * 1 + MAX_CHANNELS * ( MAX_CHANNELS + 2 + 3 * MAX_CHANNELS * MAX_CHANNELS + MAX_CHANNELS + MAX_BANDS + 1)
++     */
++
++    for(i=0;i< s->num_channels;i++){
++        memset(s->chgroup[i].decorrelation_matrix,0,sizeof(float) *s->num_channels * s->num_channels);
++    }
++
++    if(s->num_channels == 1 ){
++        s->num_chgroups = 0;
++        s->chgroup[0].num_channels = 1;
++        s->chgroup[0].no_rotation = 1;
++        s->chgroup[0].transform = 2;
++        s->channel[0].resampled_scale_factors[0] = 0;
++        memset(s->chgroup[0].transform_band,0,MAX_BANDS);
++        memset(s->chgroup[0].decorrelation_matrix,0,sizeof(float) *s->num_channels * s->num_channels);
++
++        s->chgroup[0].decorrelation_matrix[0] = 1.0;
++
++    }else{
++        int remaining_channels = s->channels_for_cur_subframe;
++
++        if(get_bits1(&s->gb)){
++            av_log(s->avctx,AV_LOG_ERROR,"unsupported channel transform bit\n");
++            return 0;
++        }
++
++        for(s->num_chgroups = 0; remaining_channels && s->num_chgroups < s->channels_for_cur_subframe;s->num_chgroups++){
++            WMA3ChannelGroup* chgroup = &s->chgroup[s->num_chgroups];
++            chgroup->num_channels = 0;
++            chgroup->no_rotation = 0;
++            chgroup->transform = 0;
++
++            /* decode channel mask */
++            memset(chgroup->use_channel,0,sizeof(chgroup->use_channel));
++
++            if(remaining_channels > 2){
++                for(i=0;i<s->channels_for_cur_subframe;i++){
++                    int channel_idx = s->channel_indexes_for_cur_subframe[i];
++                    if(!s->channel[channel_idx].grouped
++                       && get_bits1(&s->gb)){
++                        ++chgroup->num_channels;
++                        s->channel[channel_idx].grouped = 1;
++                        chgroup->use_channel[channel_idx] = 1;
++                    }
++                }
++            }else{
++                chgroup->num_channels = remaining_channels;
++                for(i=0;i<s->num_channels ;i++){
++                    chgroup->use_channel[i] = s->channel[i].grouped != 1;
++                    s->channel[i].grouped = 1;
++                }
++            }
++
++            /** done decode channel mask */
++
++            /* decide x form type
++               FIXME: port this to float, all rotations should lie
++                      on the unit circle */
++            if(chgroup->num_channels == 1){
++                chgroup->no_rotation = 1;
++                chgroup->transform = 2;
++                chgroup->decorrelation_matrix[0] = 1.0;
++
++            }else if(chgroup->num_channels == 2){
++                if(get_bits1(&s->gb)){
++                    if(!get_bits1(&s->gb)){
++                        chgroup->no_rotation = 1;
++                        chgroup->transform = 2;
++                        chgroup->decorrelation_matrix[0] = 1.0;
++                        chgroup->decorrelation_matrix[1] = 0;
++                        chgroup->decorrelation_matrix[2] = 0;
++                        chgroup->decorrelation_matrix[3] = 1.0;
++                    }
++                }else{
++                    chgroup->no_rotation = 1;
++                    chgroup->transform = 1;
++                    chgroup->decorrelation_matrix[0] = 0.70703125;  // FIXME: cos(pi/4)
++                    chgroup->decorrelation_matrix[1] = -0.70703125;
++                    chgroup->decorrelation_matrix[2] = 0.70703125;
++                    chgroup->decorrelation_matrix[3] = 0.70703125;
++                }
++            }else{
++                if(get_bits1(&s->gb)){
++                    if(get_bits1(&s->gb)){
++                        chgroup->no_rotation = 0;
++                        chgroup->transform = 0;
++                    }else{
++                        int x;
++                        chgroup->no_rotation = 1;
++                        chgroup->transform = 3;
++                        for(x = 0; x < chgroup->num_channels ; x++){
++                            int y;
++                            for(y=0;y< chgroup->num_channels ;y++){
++                                chgroup->decorrelation_matrix[y + x * chgroup->num_channels] = s->def_decorrelation_mat[chgroup->num_channels][x][y];
++                        }
++                        }
++                    }
++                }else{
++                    int i;
++                    chgroup->no_rotation = 1;
++                    chgroup->transform = 2;
++                    for(i=0;i<chgroup->num_channels;i++){
++                        chgroup->decorrelation_matrix[i+i*chgroup->num_channels] = 1.0;
++                    }
++                }
++            }
++
++            /** done decide x form type */
++
++            if(!chgroup->no_rotation){ /** decode channel transform */
++                int n_offset = chgroup->num_channels  * (chgroup->num_channels - 1) / 2;
++                int i;
++                for(i=0;i<n_offset;i++){
++                    chgroup->rotation_offset[i] = get_bits(&s->gb,6);
++                }
++                for(i=0;i<chgroup->num_channels;i++)
++                    chgroup->positive[i] = get_bits1(&s->gb);
++            }
++
++            /* decode transform on / off */
++            if(chgroup->num_channels <= 1 ||  ((chgroup->no_rotation != 1 || chgroup->transform == 2) && chgroup->no_rotation)){
++                // done
++                int i;
++                for(i=0;i<s->num_bands;i++)
++                    chgroup->transform_band[i] = 1;
++            }else{
++                if(get_bits1(&s->gb) == 0){
++                    int i;
++                    // transform works on individual scale factor bands
++                    for(i=0;i< s->num_bands;i++){
++                        chgroup->transform_band[i] = get_bits1(&s->gb);
++                    }
++                }else{
++                    int i;
++                    for(i=0;i<s->num_bands;i++)
++                        chgroup->transform_band[i] = 1;
++                }
++            }
++            /** done decode transform on / off */
++            remaining_channels -= chgroup->num_channels;
++        }
++    }
++    return 1;
++}
++
++/**
++ *@brief Decode an uncompressed coefficient.
++ *@param s codec context
++ *@return the decoded coefficient
++ */
++static unsigned int wma_get_large_val(WMA3DecodeContext* s)
++{
++    /* consumes up to 34 bits */
++    int n_bits = 8;
++    /** decode length */
++    if(get_bits1(&s->gb)){
++        n_bits += 8;
++        if(get_bits1(&s->gb)){
++            n_bits += 8;
++            if(get_bits1(&s->gb)){
++                n_bits += 7;
++            }
++        }
++    }
++    return get_bits_long(&s->gb,n_bits);
++}
++
++/**
++ *@brief Extract the coefficients from the bitstream.
++ *@param s codec context
++ *@param c current channel number
++ *@return 0 in case of bitstream errors, 1 on success
++ */
++static int wma_decode_coeffs(WMA3DecodeContext *s, int c)
++{
++    int vlctable;
++    VLC* vlc;
++    int vlcmax;
++    WMA3ChannelCtx* ci = &s->channel[c];
++    int rl_mode = 0;
++    int cur_coeff = 0;
++    int num_zeros = 0;
++    const uint8_t* run;
++    const uint8_t* level;
++    int zero_init = 0;
++    int rl_switchmask = (s->subframe_len>>8);
++
++    av_log(s->avctx,AV_LOG_DEBUG,"decode coefficients for channel %i\n",c);
++
++    vlctable = get_bits1(&s->gb);
++    vlc = &s->coef_vlc[vlctable];
++    vlcmax = s->coef_max[vlctable];
++
++    if(vlctable){
++        run = ff_wma3_coef1_run;
++        level = ff_wma3_coef1_level;
++    }else{
++        run = ff_wma3_coef0_run;
++        level = ff_wma3_coef0_level;
++    }
++
++    /* for subframe_len 128 the first zero coefficient will switch to the run length mode */
++    if(s->subframe_len == 128){
++        zero_init = num_zeros = 1;
++        rl_switchmask = 1;
++    }
++
++    /* read coefficients (consumes up to 167 bits per iteration for
++      4 vector coded large values) */
++    while(!rl_mode && cur_coeff + 3 < s->subframe_len){
++        int vals[4];
++        int i;
++        unsigned int idx;
++
++        /* read 4 values at once */
++        idx = get_vlc2(&s->gb, s->vec4_vlc.table, VLCBITS, ((FF_WMA3_HUFF_VEC4_MAXBITS+VLCBITS-1)/VLCBITS));
++
++        if ( idx == FF_WMA3_HUFF_VEC4_SIZE - 1 ){
++            i = 0;
++            while(i < 4){
++                idx = get_vlc2(&s->gb, s->vec2_vlc.table, VLCBITS, ((FF_WMA3_HUFF_VEC2_MAXBITS+VLCBITS-1)/VLCBITS));
++                if ( idx == FF_WMA3_HUFF_VEC2_SIZE - 1 ){
++                    vals[i] = get_vlc2(&s->gb, s->vec1_vlc.table, VLCBITS, ((FF_WMA3_HUFF_VEC1_MAXBITS+VLCBITS-1)/VLCBITS));
++                    if(vals[i] == FF_WMA3_HUFF_VEC1_SIZE - 1)
++                        vals[i] += wma_get_large_val(s);
++                    vals[i+1] = get_vlc2(&s->gb, s->vec1_vlc.table, VLCBITS, ((FF_WMA3_HUFF_VEC1_MAXBITS+VLCBITS-1)/VLCBITS));
++                    if(vals[i+1] == FF_WMA3_HUFF_VEC1_SIZE - 1)
++                        vals[i+1] += wma_get_large_val(s);
++                }else{
++                    vals[i] = (ff_wma3_symbol_to_vec2[idx] >> 4) & 0xF;
++                    vals[i+1] = ff_wma3_symbol_to_vec2[idx] & 0xF;
++                }
++                i += 2;
++            }
++        }else{
++             vals[0] = (ff_wma3_symbol_to_vec4[idx] >> 8) >> 4;
++             vals[1] = (ff_wma3_symbol_to_vec4[idx] >> 8) & 0xF;
++             vals[2] = (ff_wma3_symbol_to_vec4[idx] >> 4) & 0xF;
++             vals[3] = ff_wma3_symbol_to_vec4[idx] & 0xF;
++        }
++
++        for(i=0;i<4;i++){
++            if(vals[i]){
++                int sign = get_bits1(&s->gb) - 1;
++                ci->coeffs[cur_coeff] = (vals[i]^sign) - sign;
++                num_zeros = zero_init;
++            }else{
++                rl_mode |= (num_zeros & rl_switchmask);
++                ++num_zeros;
++            }
++            ++cur_coeff;
++        }
++    }
++
++    if(rl_mode){
++        unsigned int coeff_mask = s->subframe_len - 1;
++        while(cur_coeff < s->subframe_len){
++            unsigned int idx;
++            int sign;
++            int val;
++            idx = get_vlc2(&s->gb, vlc->table, VLCBITS, vlcmax);
++
++            if( idx > 1){
++                cur_coeff += run[idx];
++                val = level[idx];
++            }else if( idx == 1)
++                break;
++            else{
++                val = wma_get_large_val(s);
++                /** escape decode */
++                if(get_bits1(&s->gb)){
++                    if(get_bits1(&s->gb)){
++                        if(get_bits1(&s->gb)){
++                            av_log(s->avctx,AV_LOG_ERROR,"broken escape sequence\n");
++                            return 0;
++                        }else
++                            cur_coeff += get_bits(&s->gb,s->esc_len) + 4;
++                    }else
++                        cur_coeff += get_bits(&s->gb,2) + 1;
++                }
++            }
++            sign = get_bits1(&s->gb) - 1;
++            ci->coeffs[cur_coeff & coeff_mask] = (val^sign) - sign;
++            ++cur_coeff;
++        }
++    }
++
++    return 1;
++}
++
++/**
++ *@brief Extract scale factors from the bitstream.
++ *@param s codec context
++ *@return 0 in case of bitstream errors, 1 on success
++ */
++static int wma_decode_scale_factors(WMA3DecodeContext* s)
++{
++    int i;
++    const int idx0 = av_log2(s->samples_per_frame/s->subframe_len);
++
++    /* should never consume more than 5344 bits
++     *  MAX_CHANNELS * (1 +  MAX_BANDS * 23)
++     */
++
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++
++        /** resample scale factors for the new block size */
++        if(s->channel[c].reuse_sf){
++            const int idx1 = av_log2(s->samples_per_frame/s->channel[c].scale_factor_block_len);
++            const int* sf_offsets = &s->sf_offsets[s->num_possible_block_sizes * MAX_BANDS  * idx0
++                                                 + MAX_BANDS * idx1];
++            int b;
++            for(b=0;b<s->num_bands;b++)
++                s->channel[c].resampled_scale_factors[b] = s->channel[c].scale_factors[*sf_offsets++];
++
++            s->channel[c].max_scale_factor = s->channel[c].resampled_scale_factors[0];
++            for(b=1;b<s->num_bands;b++){
++                if(s->channel[c].resampled_scale_factors[b] > s->channel[c].max_scale_factor)
++                    s->channel[c].max_scale_factor = s->channel[c].resampled_scale_factors[b];
++            }
++        }
++
++        if(s->channel[c].cur_subframe > 0){
++            s->channel[c].transmit_sf = get_bits1(&s->gb);
++        }else
++            s->channel[c].transmit_sf = 1;
++
++        if(s->channel[c].transmit_sf){
++            int b;
++
++            if(!s->channel[c].reuse_sf){ //DPCM coded
++                int i;
++                int val;
++                s->channel[c].scale_factor_step = get_bits(&s->gb,2) + 1;
++                val = get_vlc2(&s->gb, s->sf_vlc.table, SCALEVLCBITS, ((FF_WMA3_HUFF_SCALE_MAXBITS+SCALEVLCBITS-1)/SCALEVLCBITS));
++                s->channel[c].scale_factors[0] = 45 / s->channel[c].scale_factor_step + val - 60;
++                for(i=1;i<s->num_bands;i++){
++                    val = get_vlc2(&s->gb, s->sf_vlc.table, SCALEVLCBITS, ((FF_WMA3_HUFF_SCALE_MAXBITS+SCALEVLCBITS-1)/SCALEVLCBITS));
++                    s->channel[c].scale_factors[i]  = s->channel[c].scale_factors[i-1] + val - 60;
++                }
++            }else{     // rl-coded
++                int i;
++                memcpy(s->channel[c].scale_factors,s->channel[c].resampled_scale_factors,
++                       4 * s->num_bands);
++
++                for(i=0;i<s->num_bands;i++){
++                    int idx;
++                    short skip;
++                    short val;
++                    short sign;
++
++                    idx = get_vlc2(&s->gb, s->sf_rl_vlc.table, VLCBITS, ((FF_WMA3_HUFF_SCALE_RL_MAXBITS+VLCBITS-1)/VLCBITS));
++
++                    if( !idx ){
++                        uint32_t code = get_bits(&s->gb,14);
++                        val = code >> 6;
++                        sign = (code & 1) - 1;
++                        skip = (code & 0x3f)>>1;
++                    }else if(idx == 1){
++                        break;
++                    }else{
++                        skip = ff_wma3_scale_rl_run[idx];
++                        val = ff_wma3_scale_rl_level[idx];
++                        sign = get_bits1(&s->gb)-1;
++                    }
++
++                    i += skip;
++                    if(i >= s->num_bands){
++                        av_log(s->avctx,AV_LOG_ERROR,"invalid scale factor coding\n");
++                        return 0;
++                    }else
++                        s->channel[c].scale_factors[i] += (val ^ sign) - sign;
++                }
++            }
++
++            s->channel[c].reuse_sf = 1;
++            s->channel[c].max_scale_factor = s->channel[c].scale_factors[0];
++            for(b=1;b<s->num_bands;b++){
++                if(s->channel[c].max_scale_factor < s->channel[c].scale_factors[b])
++                    s->channel[c].max_scale_factor = s->channel[c].scale_factors[b];
++            }
++            s->channel[c].scale_factor_block_len = s->subframe_len;
++        }
++    }
++    return 1;
++}
++
++/**
++ *@brief Calculate a decorrelation matrix from the bitstream parameters.
++ *@param s codec context
++ *@param chgroup channel group for which the matrix needs to be calculated
++ */
++static void wma_calc_decorrelation_matrix(WMA3DecodeContext *s, WMA3ChannelGroup* chgroup)
++{
++    int i;
++    int offset = 0;
++    memset(chgroup->decorrelation_matrix, 0, chgroup->num_channels * sizeof(float) * chgroup->num_channels);
++    for(i=0;i<chgroup->num_channels;i++)
++        chgroup->decorrelation_matrix[chgroup->num_channels * i + i] = chgroup->positive[i]?1.0:-1.0;
++
++    for(i=0;i<chgroup->num_channels;i++){
++        if ( i > 0 )
++        {
++            int x;
++            for(x=0;x<i;x++){
++                int y;
++                float tmp1[MAX_CHANNELS];
++                float tmp2[MAX_CHANNELS];
++                memcpy(tmp1, &chgroup->decorrelation_matrix[x * chgroup->num_channels], sizeof(float) * (i + 1));
++                memcpy(tmp2, &chgroup->decorrelation_matrix[i * chgroup->num_channels], sizeof(float) * (i + 1));
++                for(y=0;y < i + 1 ; y++){
++                    float v1 = tmp1[y];
++                    float v2 = tmp2[y];
++                    int n = chgroup->rotation_offset[offset + x];
++                    float cosv = sin(n*M_PI / 64.0);                // FIXME: use one table for this
++                    float sinv = -cos(n*M_PI / 64.0);
++
++                    chgroup->decorrelation_matrix[y + x * chgroup->num_channels] = (v1 * cosv) + (v2 * sinv);
++                    chgroup->decorrelation_matrix[y + i * chgroup->num_channels] = (v1 * -sinv) + (v2 * cosv);
++                }
++            }
++        }
++        offset += i;
++    }
++
++}
++
++/**
++ *@brief Decorrelate and undo M/S stereo coding.
++ *@param s codec context
++ */
++static void wma_inverse_channel_transform(WMA3DecodeContext *s)
++{
++    int i;
++
++    for(i=0;i<s->num_chgroups;i++){
++
++        if(s->chgroup[i].num_channels == 1)
++            continue;
++
++        if(s->chgroup[i].no_rotation == 1 && s->chgroup[i].transform == 2)
++            continue;
++
++        if((s->num_channels == 2) &&
++            (s->chgroup[i].no_rotation == 1) &&
++            (s->chgroup[i].transform == 1)){
++            int b;
++            for(b = 0; b < s->num_bands;b++){
++                int y;
++                if(s->chgroup[i].transform_band[b] == 1){ // M/S stereo
++                    for(y=s->cur_sfb_offsets[b];y<FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);y++){
++                        float v1 = s->channel[0].coeffs[y];
++                        float v2 = s->channel[1].coeffs[y];
++                        s->channel[0].coeffs[y] = v1 - v2;
++                        s->channel[1].coeffs[y] = v1 + v2;
++                    }
++                }else{
++                    for(y=s->cur_sfb_offsets[b];y<FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);y++){
++                        s->channel[0].coeffs[y] *= 181.0 / 128;
++                        s->channel[1].coeffs[y] *= 181.0 / 128;
++                    }
++                }
++            }
++        }else{
++            int x;
++            int b;
++            int cnt = 0;
++            float* ch_data[MAX_CHANNELS];
++            float  sums[MAX_CHANNELS * MAX_CHANNELS];
++            if(!s->chgroup[i].no_rotation)
++                wma_calc_decorrelation_matrix(s,&s->chgroup[i]);
++
++            for(x=0;x<s->channels_for_cur_subframe;x++){
++                int chan = s->channel_indexes_for_cur_subframe[x];
++                if(s->chgroup[i].use_channel[chan] == 1){    // assign ptrs
++                    ch_data[cnt] = s->channel[chan].coeffs;
++                    ++cnt;
++                }
++            }
++
++            for(b = 0; b < s->num_bands;b++){
++                int y;
++                if(s->chgroup[i].transform_band[b] == 1){
++                    // multiply values with decorrelation_matrix
++                    for(y=s->cur_sfb_offsets[b];y<FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);y++){
++                        float* matrix = s->chgroup[i].decorrelation_matrix;
++                        int m;
++
++                        for(m = 0;m<s->chgroup[i].num_channels;m++)
++                            sums[m] = 0;
++
++                        for(m = 0;m<s->chgroup[i].num_channels;m++){
++                            int k;
++                            for(k=0;k<s->chgroup[i].num_channels;k++)
++                                sums[m] += (matrix[m*s->chgroup[i].num_channels+k] * ch_data[k][0]);
++                        }
++
++                        for(m = 0;m<s->chgroup[i].num_channels;m++){
++                            ch_data[m][0] = sums[m];
++                            ++ch_data[m];
++                        }
++                    }
++                }else{      /** skip band */
++                    for(y=0;y<s->chgroup[i].num_channels;y++)
++                        ch_data[y] += s->cur_sfb_offsets[b+1] -  s->cur_sfb_offsets[b];
++                }
++            }
++        }
++    }
++}
++
++/**
++ *@brief Apply sine window and reconstruct the output buffer.
++ *@param s codec context
++ */
++static void wma_window(WMA3DecodeContext *s)
++{
++    int i;
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++        int j = s->channel[c].cur_subframe;
++        float* start;
++        float* window;
++        int prev_block_len = s->channel[c].prev_block_len;
++        int block_len = s->channel[c].subframe_len[j];
++        int winlen = prev_block_len;
++        start = &s->channel[c].out[s->samples_per_frame/2 + s->channel[c].subframe_offset[j] - prev_block_len /2 ];
++
++        if(block_len <= prev_block_len){
++            start += (prev_block_len - block_len)/2;
++            winlen = block_len;
++        }
++
++        window = s->windows[av_log2(winlen)-BLOCK_MIN_BITS];
++
++        s->dsp.vector_fmul_window(start, start, start + winlen/2, window, 0, winlen/2);
++
++        s->channel[c].prev_block_len = block_len;
++    }
++}
++
++/**
++ *@brief Decode a single subframe (block).
++ *@param s codec context
++ *@return 0 if decoding failed, 1 on success
++ */
++static int wma_decode_subframe(WMA3DecodeContext *s)
++{
++    int offset = s->samples_per_frame;
++    int subframe_len = s->samples_per_frame;
++    int i;
++    int total_samples = s->samples_per_frame * s->num_channels;
++    int transmit_coeffs = 0;
++
++    s->subframe_offset = get_bits_count(&s->gb);
++
++    /** reset channel context and find the next block offset and size
++        == the next block of the channel with the smallest number of decoded samples
++    */
++    for(i=0;i<s->num_channels;i++){
++        s->channel[i].grouped = 0;
++        if(offset > s->channel[i].decoded_samples){
++            offset = s->channel[i].decoded_samples;
++            subframe_len = s->channel[i].subframe_len[s->channel[i].cur_subframe];
++        }
++    }
++
++    av_log(s->avctx, AV_LOG_DEBUG,"processing subframe with offset %i len %i\n",offset,subframe_len);
++
++    /** get a list of all channels that contain the estimated block */
++    s->channels_for_cur_subframe = 0;
++    for(i=0;i<s->num_channels;i++){
++        /** substract already processed samples */
++        total_samples -= s->channel[i].decoded_samples;
++
++        /** and count if there are multiple subframes that match our profile */
++        if(offset == s->channel[i].decoded_samples && subframe_len == s->channel[i].subframe_len[s->channel[i].cur_subframe]){
++             total_samples -= s->channel[i].subframe_len[s->channel[i].cur_subframe];
++             s->channel[i].decoded_samples += s->channel[i].subframe_len[s->channel[i].cur_subframe];
++             s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;
++             ++s->channels_for_cur_subframe;
++        }
++    }
++
++    /** check if the frame will be complete after processing the estimated block */
++    if(total_samples == 0)
++        s->parsed_all_subframes = 1;
++
++
++    av_log(s->avctx, AV_LOG_DEBUG,"subframe is part of %i channels\n",s->channels_for_cur_subframe);
++
++    /** configure the decoder for the current subframe */
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++
++        /** calculate number of scale factor bands and their offsets */
++        /** FIXME move out of the loop */
++        if(i == 0){
++            if(s->channel[c].num_subframes <= 1){
++                s->num_bands = s->num_sfb[0];
++                s->cur_sfb_offsets = s->sfb_offsets;
++                s->cur_subwoofer_cutoff = s->subwoofer_cutoffs[0];
++            }else{
++                int frame_offset = av_log2(s->samples_per_frame/s->channel[c].subframe_len[s->channel[c].cur_subframe]);
++                s->num_bands = s->num_sfb[frame_offset];
++                s->cur_sfb_offsets = &s->sfb_offsets[MAX_BANDS * frame_offset];
++                s->cur_subwoofer_cutoff = s->subwoofer_cutoffs[frame_offset];
++            }
++        }
++        s->channel[c].coeffs = &s->channel[c].out[s->samples_per_frame/2  + offset];
++        memset(s->channel[c].coeffs,0,sizeof(float) * subframe_len);
++
++        /** init some things if this is the first subframe */
++        if(!s->channel[c].cur_subframe){
++              s->channel[c].scale_factor_step = 1;
++              s->channel[c].max_scale_factor = 0;
++              memset(s->channel[c].scale_factors, 0, sizeof(s->channel[c].scale_factors));
++              memset(s->channel[c].resampled_scale_factors, 0, sizeof(s->channel[c].resampled_scale_factors));
++        }
++
++    }
++
++    s->subframe_len = subframe_len;
++    s->esc_len = av_log2(s->subframe_len - 1) + 1;
++
++    /** skip extended header if any */
++    if(get_bits1(&s->gb)){
++        int num_fill_bits;
++        if(!(num_fill_bits = get_bits(&s->gb,2))){
++            num_fill_bits = get_bits(&s->gb,4);
++            num_fill_bits = get_bits(&s->gb,num_fill_bits) + 1;
++        }
++
++        if(num_fill_bits >= 0){
++            if(get_bits_count(&s->gb) + num_fill_bits > s->num_saved_bits){
++                av_log(s->avctx,AV_LOG_ERROR,"invalid number of fill bits\n");
++                return 0;
++            }
++
++            skip_bits_long(&s->gb,num_fill_bits);
++        }
++    }
++
++    /** no idea for what the following bit is used */
++    if(get_bits1(&s->gb)){
++        av_log(s->avctx,AV_LOG_ERROR,"reserved bit set\n");
++        return 0;
++    }
++
++
++    if(!wma_decode_channel_transform(s))
++        return 0;
++
++
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++        if((s->channel[c].transmit_coefs = get_bits1(&s->gb)))
++            transmit_coeffs = 1;
++    }
++
++    s->quant_step = 90 * s->sample_bit_depth / 16;
++
++    if(transmit_coeffs){
++        int quant;
++        int sign = 1;
++        int large_quant = 0;
++        if((get_bits1(&s->gb))){ /** FIXME: might influence how often getvec4 may be called */
++            av_log(s->avctx,AV_LOG_ERROR,"unsupported quant step coding\n");
++            return 0;
++        }
++        /** decode quantization step */
++        quant = get_bits(&s->gb,6);
++        if(quant & 0x20){
++            quant |= 0xFFFFFFC0u;
++            sign = -1;
++        }
++        s->quant_step += quant;
++        if(quant <= -32 || quant > 30)
++            large_quant = 1;
++        while(large_quant && (get_bits_count(&s->gb) + 5 < s->num_saved_bits)){
++            quant = get_bits(&s->gb,5);
++            if(quant != 31){
++                s->quant_step += quant * sign;
++                break;
++            }
++            s->quant_step += 31 * sign;
++            if(s->quant_step < 0){
++                av_log(s->avctx,AV_LOG_ERROR,"negative quant step\n");
++            }
++        }
++
++        /** decode quantization step modifiers for every channel */
++
++        if(s->channels_for_cur_subframe == 1)
++            s->channel[s->channel_indexes_for_cur_subframe[0]].quant_step_modifier = 0;
++        else{
++            int modifier_len = get_bits(&s->gb,3);
++            for(i=0;i<s->channels_for_cur_subframe;i++){
++                int c = s->channel_indexes_for_cur_subframe[i];
++                s->channel[c].quant_step_modifier = 0;
++                if(get_bits1(&s->gb)){
++                    if(modifier_len)
++                        s->channel[c].quant_step_modifier = get_bits(&s->gb,modifier_len) + 1;
++                    else
++                        s->channel[c].quant_step_modifier = 1;
++                }else
++                    s->channel[c].quant_step_modifier = 0;
++
++            }
++        }
++
++        /** decode scale factors */
++        if(!wma_decode_scale_factors(s))
++            return 0;
++    }
++
++    av_log(s->avctx,AV_LOG_DEBUG,"BITSTREAM: subframe header length was %i\n",get_bits_count(&s->gb) - s->subframe_offset);
++
++    /** parse coefficients */
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++        if(s->channel[c].transmit_coefs && get_bits_count(&s->gb) < s->num_saved_bits)
++                wma_decode_coeffs(s,c);
++    }
++
++    av_log(s->avctx,AV_LOG_DEBUG,"BITSTREAM: subframe length was %i\n",get_bits_count(&s->gb) - s->subframe_offset);
++
++    if(transmit_coeffs){
++        wma_inverse_channel_transform(s);
++        for(i=0;i<s->channels_for_cur_subframe;i++){
++            int c = s->channel_indexes_for_cur_subframe[i];
++            int b;
++            float* dst;
++            if(c == s->lfe_channel)
++                memset(&s->tmp[s->cur_subwoofer_cutoff],0,sizeof(float) * (subframe_len - s->cur_subwoofer_cutoff));
++
++            /** inverse quantization */
++            for(b=0;b<s->num_bands;b++){
++                int start = s->cur_sfb_offsets[b];
++                int end = s->cur_sfb_offsets[b+1];
++                int min;
++                float quant;
++                if(end > s->subframe_len)
++                    end = s->subframe_len;
++
++                if(s->channel[c].transmit_sf)
++                     min = s->channel[c].scale_factor_step * (s->channel[c].max_scale_factor - s->channel[c].scale_factors[b]);
++                else
++                     min = s->channel[c].scale_factor_step * (s->channel[c].max_scale_factor - s->channel[c].resampled_scale_factors[b]);
++                quant = pow(10.0,(s->quant_step + s->channel[c].quant_step_modifier - min) / 20.0);
++                while(start < end){
++                    s->tmp[start] = s->channel[c].coeffs[start] * quant;
++                    ++start;
++                }
++            }
++
++            dst = &s->channel[c].out[s->samples_per_frame/2  + s->channel[c].subframe_offset[s->channel[c].cur_subframe]];
++            ff_imdct_half(&s->mdct_ctx[av_log2(subframe_len)-BLOCK_MIN_BITS], dst, s->tmp); // DCTIV with reverse
++        }
++    }else{
++        for(i=0;i<s->channels_for_cur_subframe;i++){
++            int c = s->channel_indexes_for_cur_subframe[i];
++            float* dst;
++            dst = &s->channel[c].out[s->samples_per_frame/2  + s->channel[c].subframe_offset[s->channel[c].cur_subframe]];
++            memset(dst,0,subframe_len * sizeof(float));
++        }
++    }
++
++    wma_window(s);
++
++    /** handled one subframe */
++    for(i=0;i<s->channels_for_cur_subframe;i++){
++        int c = s->channel_indexes_for_cur_subframe[i];
++        if(s->channel[c].cur_subframe >= s->channel[c].num_subframes){
++            av_log(s->avctx,AV_LOG_ERROR,"broken subframe\n");
++            return 0;
++        }
++        ++s->channel[c].cur_subframe;
++    }
++
++    return 1;
++}
++
++/**
++ *@brief Decode one WMA frame.
++ *@param s codec context
++ *@return 0 if the trailer bit indicates that this is the last frame,
++ *        1 if there are additional frames
++ */
++static int wma_decode_frame(WMA3DecodeContext *s)
++{
++    GetBitContext* gb = &s->gb;
++    int more_frames = 0;
++    int len = 0;
++    int i;
++
++    /** check for potential output buffer overflow */
++    if(s->samples + s->num_channels * s->samples_per_frame > s->samples_end){
++        av_log(s->avctx,AV_LOG_ERROR,"not enough space for the output samples\n");
++        s->packet_loss = 1;
++        return 0;
++    }
++
++    /** get frame length */
++    if(s->len_prefix)
++        len = get_bits(gb,s->log2_frame_size);
++
++    av_log(s->avctx,AV_LOG_DEBUG,"decoding frame with length %x\n",len);
++
++    /** decode tile information */
++    if(wma_decode_tilehdr(s)){
++        s->packet_loss = 1;
++        return 0;
++    }
++
++    /** read postproc transform */
++    if(s->num_channels > 1 && get_bits1(gb)){
++        av_log(s->avctx,AV_LOG_ERROR,"Unsupported postproc transform found\n");
++        s->packet_loss = 1;
++        return 0;
++    }
++
++    /** read drc info */
++    if(s->dynamic_range_compression){
++        s->drc_gain = get_bits(gb,8);
++        av_log(s->avctx,AV_LOG_DEBUG,"drc_gain %i\n",s->drc_gain);
++    }
++
++    /** no idea what these are for, might be the number of samples
++        that need to be skipped at the beginning or end of a stream */
++    if(get_bits1(gb)){
++        int skip;
++
++        /** usually true for the first frame */
++        if(get_bits1(gb)){
++            skip = get_bits(gb,av_log2(s->samples_per_frame * 2));
++            av_log(s->avctx,AV_LOG_DEBUG,"start skip: %i\n",skip);
++        }
++
++        /** sometimes true for the last frame */
++        if(get_bits1(gb)){
++            skip = get_bits(gb,av_log2(s->samples_per_frame * 2));
++            av_log(s->avctx,AV_LOG_DEBUG,"end skip: %i\n",skip);
++        }
++
++    }
++
++    av_log(s->avctx,AV_LOG_DEBUG,"BITSTREAM: frame header length was %i\n",get_bits_count(gb) - s->frame_offset);
++
++    /** reset subframe states */
++    s->parsed_all_subframes = 0;
++    for(i=0;i<s->num_channels;i++){
++        s->channel[i].decoded_samples = 0;
++        s->channel[i].cur_subframe = 0;
++        s->channel[i].reuse_sf = 0;
++    }
++
++    /** parse all subframes */
++    while(!s->parsed_all_subframes){
++        if(!wma_decode_subframe(s)){
++            s->packet_loss = 1;
++            return 0;
++        }
++    }
++
++    /** convert samples to short and write them to the output buffer */
++    for(i = 0; i < s->num_channels; i++) {
++        int16_t* ptr;
++        int incr = s->num_channels;
++        float* iptr = s->channel[i].out;
++        int x;
++
++        ptr = s->samples + i;
++
++        for(x=0;x<s->samples_per_frame;x++) {
++            *ptr = av_clip_int16(lrintf(*iptr++));
++            ptr += incr;
++        }
++
++        /** reuse second half of the IMDCT output for the next frame */
++        memmove(&s->channel[i].out[0], &s->channel[i].out[s->samples_per_frame],
++                s->samples_per_frame * sizeof(float));
++    }
++
++    if(s->skip_frame)
++        s->skip_frame = 0;
++    else
++        s->samples += s->num_channels * s->samples_per_frame;
++
++    if(len != (get_bits_count(gb) - s->frame_offset) + 2){
++        /* FIXME: not sure if this is always an error */
++        av_log(s->avctx,AV_LOG_ERROR,"frame[%i] would have to skip %i bits\n",s->frame_num,len - (get_bits_count(gb) - s->frame_offset) - 1);
++        s->packet_loss = 1;
++        return 0;
++    }
++
++    /** skip the rest of the frame data */
++    skip_bits_long(gb,len - (get_bits_count(gb) - s->frame_offset) - 1);
++
++    /** decode trailer bit */
++    more_frames = get_bits1(gb);
++
++    ++s->frame_num;
++    return more_frames;
++}
++
++/**
++ *@brief Calculate remaining input buffer length.
++ *@param s codec context
++ *@param gb bitstream reader context
++ *@return remaining size in bits
++ */
++static int wma_remaining_bits(WMA3DecodeContext *s, GetBitContext* gb)
++{
++    return s->buf_bit_size - get_bits_count(gb);
++}
++
++/**
++ *@brief Fill the bit reservoir with a (partial) frame.
++ *@param s codec context
++ *@param gb bitstream reader context
++ *@param len length of the partial frame
++ *@param append decides wether to reset the buffer or not
++ */
++static void wma_save_bits(WMA3DecodeContext *s, GetBitContext* gb, int len, int append)
++{
++    int buflen;
++    int bit_offset;
++    int pos;
++
++    if(!append){
++        s->frame_offset = get_bits_count(gb) & 7;
++        s->num_saved_bits = s->frame_offset;
++    }
++
++    buflen = (s->num_saved_bits + len + 8) >> 3;
++
++    if(len <= 0 || buflen > MAX_FRAMESIZE){
++         av_log(s->avctx, AV_LOG_ERROR, "input buffer to small\n");
++         s->packet_loss = 1;
++         return;
++    }
++
++    if(!append){
++        s->num_saved_bits += len;
++        memcpy(s->frame_data, gb->buffer + (get_bits_count(gb) >> 3), (s->num_saved_bits  + 8)>> 3);
++        skip_bits_long(gb, len);
++    }else{
++        bit_offset = s->num_saved_bits & 7;
++        pos = (s->num_saved_bits - bit_offset) >> 3;
++
++        s->num_saved_bits += len;
++
++        /** byte align prev_frame buffer */
++        if(bit_offset){
++            int missing = 8 - bit_offset;
++            if(len < missing)
++                missing = len;
++            s->frame_data[pos++] |=
++                get_bits(gb, missing) << (8 - bit_offset - missing);
++            len -= missing;
++        }
++
++        /** copy full bytes */
++        while(len > 7){
++            s->frame_data[pos++] = get_bits(gb,8);
++            len -= 8;
++        }
++
++        /** copy remaining bits */
++        if(len > 0)
++            s->frame_data[pos++] = get_bits(gb,len) << (8 - len);
++
++    }
++
++    init_get_bits(&s->gb, s->frame_data,s->num_saved_bits);
++    skip_bits(&s->gb, s->frame_offset);
++}
++
++/**
++ *@brief Decode a single WMA packet.
++ *@param avctx codec context
++ *@param data the output buffer
++ *@param data_size number of bytes that were written to the output buffer
++ *@param avpkt input packet
++ *@return number of bytes that were read from the input buffer
++ */
++static int wma_decode_packet(AVCodecContext *avctx,
++                             void *data, int *data_size, AVPacket* avpkt)
++{
++    GetBitContext gb;
++    WMA3DecodeContext *s = avctx->priv_data;
++    const uint8_t* buf = avpkt->data;
++    int buf_size = avpkt->size;
++    int more_frames=1;
++    int num_bits_prev_frame;
++    int packet_sequence_number;
++
++    s->samples = data;
++    s->samples_end = (int16_t*)((int8_t*)data + *data_size);
++    s->buf_bit_size = buf_size << 3;
++
++
++    *data_size = 0;
++
++    /** sanity check for the buffer length */
++    if(buf_size < avctx->block_align)
++        return 0;
++
++    buf_size = avctx->block_align;
++
++    /** parse packet header */
++    init_get_bits(&gb, buf, s->buf_bit_size);
++    packet_sequence_number    = get_bits(&gb, 4);
++    s->bit5                   = get_bits1(&gb);
++    s->bit6                   = get_bits1(&gb);
++
++    /** get number of bits that need to be added to the previous frame */
++    num_bits_prev_frame = get_bits(&gb, s->log2_frame_size);
++    av_log(avctx, AV_LOG_DEBUG, "packet[%d]: nbpf %x\n", avctx->frame_number,
++                  num_bits_prev_frame);
++
++    /** check for packet loss */
++    if (!s->packet_loss &&
++        ((s->packet_sequence_number + 1)&0xF) != packet_sequence_number) {
++        s->packet_loss = 1;
++        av_log(avctx, AV_LOG_ERROR, "Packet loss detected! seq %x vs %x\n",
++                      s->packet_sequence_number,packet_sequence_number);
++    }
++    s->packet_sequence_number = packet_sequence_number;
++
++    if (num_bits_prev_frame > 0) {
++        /** append the previous frame data to the remaining data from the
++            previous packet to create a full frame */
++        wma_save_bits(s, &gb, num_bits_prev_frame, 1);
++        av_log(avctx, AV_LOG_DEBUG, "accumulated %x bits of frame data\n",
++                      s->num_saved_bits - s->frame_offset);
++
++        /** decode the cross packet frame if it is valid */
++        if(!s->packet_loss)
++            wma_decode_frame(s);
++    }else if(s->num_saved_bits - s->frame_offset){
++        av_log(avctx, AV_LOG_DEBUG, "ignoring %x previously saved bits\n",
++                      s->num_saved_bits - s->frame_offset);
++    }
++
++    s->packet_loss = 0;
++    /** decode the rest of the packet */
++    while(!s->packet_loss && more_frames && wma_remaining_bits(s,&gb) > s->log2_frame_size){
++        int frame_size = show_bits(&gb, s->log2_frame_size);
++
++        /** there is enough data for a full frame */
++        if(wma_remaining_bits(s,&gb) >= frame_size){
++            wma_save_bits(s, &gb, frame_size, 0);
++
++            /** decode the frame */
++            more_frames = wma_decode_frame(s);
++
++            if(!more_frames){
++                av_log(avctx, AV_LOG_DEBUG, "no more frames\n");
++            }
++        }else
++            more_frames = 0;
++    }
++
++    if(!s->packet_loss){
++        /** save the rest of the data so that it can be decoded
++            with the next packet */
++        wma_save_bits(s, &gb, wma_remaining_bits(s,&gb), 0);
++    }
++
++    *data_size = (int8_t *)s->samples - (int8_t *)data;
++
++    return avctx->block_align;
++}
++
++/**
++ *@brief Clear decoder buffers (for seeking).
++ *@param avctx codec context
++ */
++static void wma_flush(AVCodecContext *avctx)
++{
++    WMA3DecodeContext *s = avctx->priv_data;
++    int i;
++    for(i=0;i<s->num_channels;i++)
++        memset(s->channel[i].out, 0, sizeof(s->channel[0].out));
++    s->packet_loss = 1;
++}
++
++
++/**
++ *@brief WMA9 decoder
++ */
++AVCodec wmapro_decoder =
++{
++    "wmapro",
++    CODEC_TYPE_AUDIO,
++    CODEC_ID_WMAPRO,
++    sizeof(WMA3DecodeContext),
++    wma_decode_init,
++    NULL,
++    wma_decode_end,
++    wma_decode_packet,
++    .flush= wma_flush,
++    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 9 Professional"),
++};

Cambios de propiedades en debian-rvm/patches/13-wmapro.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/03-runtime_eq.dpatch
===================================================================
--- debian-rvm/patches/03-runtime_eq.dpatch	(revisión: 0)
+++ debian-rvm/patches/03-runtime_eq.dpatch	(revisión: 0)
@@ -0,0 +1,90 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 03-runtime_eq.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad svn~/DOCS/tech/slave.txt svn/DOCS/tech/slave.txt
+--- svn~/DOCS/tech/slave.txt	2009-05-20 13:32:19.000000000 +0200
++++ svn/DOCS/tech/slave.txt	2009-05-20 13:36:06.000000000 +0200
+@@ -463,6 +463,11 @@
+     Run <value> as shell command. In OSD menu console mode stdout and stdin
+     are through the video output driver.
+ 
++af_eq_set_bands <values>
++    Set bands gain in audio equalizer. Se details in manual (-af equalizer).
++    Example:
++       af_eq_set_bands 11:11:10:5:0:-12:0:5:12:12
++
+ 
+ Available properties:
+ 
+diff -urNad svn~/command.c svn/command.c
+--- svn~/command.c	2009-05-20 13:32:28.000000000 +0200
++++ svn/command.c	2009-05-20 13:36:06.000000000 +0200
+@@ -2970,6 +2970,13 @@
+ 	    }
+ 	    break;
+ 
++	case MP_CMD_AF_EQ_SET:{  
++      af_instance_t* m1=af_get(sh_audio->afilter, "equalizer");
++      if (m1) m1->control( m1, AF_CONTROL_COMMAND_LINE, cmd->args[0].v.s);
++      else mp_msg(MSGT_CPLAYER, MSGL_INFO, "failed (forgot -af equalizer=0:0 ?)\n");
++	    }
++      break;
++
+ 	case MP_CMD_VF_CHANGE_RECTANGLE:
+             if (!sh_video)
+                 break;
+diff -urNad svn~/input/input.c svn/input/input.c
+--- svn~/input/input.c	2009-05-20 13:32:09.000000000 +0200
++++ svn/input/input.c	2009-05-20 13:36:06.000000000 +0200
+@@ -172,6 +172,7 @@
+   { MP_CMD_LOADLIST, "loadlist", 1, { {MP_CMD_ARG_STRING, {0}}, {MP_CMD_ARG_INT,{0}}, {-1,{0}} } },
+   { MP_CMD_RUN, "run", 1, { {MP_CMD_ARG_STRING,{0}}, {-1,{0}} } },
+   { MP_CMD_VF_CHANGE_RECTANGLE, "change_rectangle", 2, { {MP_CMD_ARG_INT,{0}}, {MP_CMD_ARG_INT,{0}}, {-1,{0}}}},
++  { MP_CMD_AF_EQ_SET, "af_eq_set_bands", 1, { {MP_CMD_ARG_STRING, {0}}, {-1,{0}}}}, //turbos
+ #ifdef CONFIG_TV_TELETEXT
+   { MP_CMD_TV_TELETEXT_ADD_DEC, "teletext_add_dec", 1, { {MP_CMD_ARG_STRING,{0}}, {-1,{0}} } },
+   { MP_CMD_TV_TELETEXT_GO_LINK, "teletext_go_link", 1, { {MP_CMD_ARG_INT,{0}}, {-1,{0}} } },
+diff -urNad svn~/input/input.h svn/input/input.h
+--- svn~/input/input.h	2009-05-20 13:32:09.000000000 +0200
++++ svn/input/input.h	2009-05-20 13:36:06.000000000 +0200
+@@ -129,6 +129,7 @@
+   MP_CMD_ASS_USE_MARGINS,
+   MP_CMD_SWITCH_TITLE,
+   MP_CMD_STOP,
++  MP_CMD_AF_EQ_SET,
+ 
+   /// DVDNAV commands
+   MP_CMD_DVDNAV_UP = 1000,
+diff -urNad svn~/libaf/af_equalizer.c svn/libaf/af_equalizer.c
+--- svn~/libaf/af_equalizer.c	2009-05-20 13:32:28.000000000 +0200
++++ svn/libaf/af_equalizer.c	2009-05-20 13:36:06.000000000 +0200
+@@ -140,6 +140,7 @@
+   case AF_CONTROL_COMMAND_LINE:{
+     float g[10]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
+     int i,j;
++    float gain_factor2=0.0;
+     sscanf((char*)arg,"%f:%f:%f:%f:%f:%f:%f:%f:%f:%f", &g[0], &g[1],
+ 	   &g[2], &g[3], &g[4], &g[5], &g[6], &g[7], &g[8] ,&g[9]);
+     for(i=0;i<AF_NCH;i++){
+@@ -148,6 +149,17 @@
+ 	  pow(10.0,clamp(g[j],G_MIN,G_MAX)/20.0)-1.0;
+       }
+     }
++    
++    //calculate gainfactor for slave command
++    //see: af_eq_set_bands  -> input.c
++    //see code: AF_CONTROL_REINIT  in this file
++     for(j=0;j<KM;j++)
++        if(gain_factor2< s->g[0][j]) gain_factor2=s->g[0][j];
++     gain_factor2=log10(gain_factor2 + 1.0) * 20.0;
++     if(gain_factor2 > 0.0)   gain_factor2=0.1+(gain_factor2/12.0);
++     else gain_factor2=1;
++     s->gain_factor=gain_factor2;
++    
+     return AF_OK;
+   }
+   case AF_CONTROL_EQUALIZER_GAIN | AF_CONTROL_SET:{

Cambios de propiedades en debian-rvm/patches/03-runtime_eq.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/04-ass_for_mencoder.dpatch
===================================================================
--- debian-rvm/patches/04-ass_for_mencoder.dpatch	(revisión: 0)
+++ debian-rvm/patches/04-ass_for_mencoder.dpatch	(revisión: 0)
@@ -0,0 +1,489 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 04-ass_for_mencoder.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad svn~/DOCS/man/en/mplayer.1 svn/DOCS/man/en/mplayer.1
+--- svn~/DOCS/man/en/mplayer.1	2008-10-19 09:17:10.000000000 +0200
++++ svn/DOCS/man/en/mplayer.1	2008-10-19 09:42:21.000000000 +0200
+@@ -7171,6 +7171,48 @@
+ Threshold below which a pixel value is considered black (default: 32).
+ .RE
+ .
++.TP
++.B fixpts[=options]
++Fixes the presentation timestamps (PTS) of the frames.
++By default, the PTS passed to the next filter is dropped, but the following
++options can change that:
++.RSs
++.IPs print
++Print the incoming PTS.
++.IPs fps=<fps>
++Specify a frame per second value.
++.IPs start=<pts>
++Specify an initial value for the PTS.
++.IPs autostart=<n>
++Uses the 
++.IR n th
++incoming PTS as the initial PTS.
++All previous pts are kept, so setting a huge value or \-1 keeps the PTS
++intact.
++.IPs autofps=<n>
++Uses the 
++.IR n th
++incoming PTS after the end of autostart to determine the framerate.
++.RE
++.sp 1
++.RS
++.I EXAMPLE:
++.RE
++.PD 0
++.RSs
++.IPs "\-vf fixpts=fps=24000/1001,ass,fixpts"
++Generates a new sequence of PTS, uses it for ASS subtitles, then drops it.
++Generating a new sequence is useful when the timestamps are reset during the
++program; this is frequent on DVDs.
++Dropping it may be necessary to avoid confusing encoders.
++.RE
++.PD 1
++.sp 1
++.RS
++.I NOTE:
++Using this filter together with any sort of seeking (including -ss and EDLs)
++may make demons fly out of your nose.
++.RE
+ .
+ .
+ .SH "GENERAL ENCODING OPTIONS (MENCODER ONLY)"
+@@ -7293,6 +7335,14 @@
+ Do not write OpenDML index for AVI files >1GB.
+ .
+ .TP
++.B \-keep\-pts
++Send the original presentation timestamp (PTS) down the filter and encoder
++chain.
++This may cause incorrect output ("badly interleaved") if the original PTS
++are wrong or the framerate is changed, but can be necessary for certain
++filters (such as ASS).
++.
++.TP
+ .B \-noskip
+ Do not skip frames.
+ .
+diff -urNad svn~/Makefile svn/Makefile
+--- svn~/Makefile	2008-10-19 09:17:10.000000000 +0200
++++ svn/Makefile	2008-10-19 09:42:21.000000000 +0200
+@@ -125,6 +125,7 @@
+               libmpcodecs/vf_field.c \
+               libmpcodecs/vf_fil.c \
+               libmpcodecs/vf_filmdint.c \
++              libmpcodecs/vf_fixpts.c \
+               libmpcodecs/vf_flip.c \
+               libmpcodecs/vf_format.c \
+               libmpcodecs/vf_framestep.c \
+diff -urNad svn~/cfg-mencoder.h svn/cfg-mencoder.h
+--- svn~/cfg-mencoder.h	2008-10-19 09:17:10.000000000 +0200
++++ svn/cfg-mencoder.h	2008-10-19 09:42:21.000000000 +0200
+@@ -213,6 +213,9 @@
+ 	
+ 	{"odml", &write_odml, CONF_TYPE_FLAG, CONF_GLOBAL, 0, 1, NULL},
+ 	{"noodml", &write_odml, CONF_TYPE_FLAG, CONF_GLOBAL, 1, 0, NULL},
++
++	{"keep-pts", &keep_pts, CONF_TYPE_FLAG, 0, 0, 1, NULL},
++	{"nokeep-pts", &keep_pts, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+ 	
+ 	// info header strings
+ 	{"info", info_conf, CONF_TYPE_SUBCONFIG, CONF_GLOBAL, 0, 0, NULL},
+diff -urNad svn~/libass/ass_cache.c svn/libass/ass_cache.c
+--- svn~/libass/ass_cache.c	2008-10-19 09:17:10.000000000 +0200
++++ svn/libass/ass_cache.c	2008-10-19 09:42:21.000000000 +0200
+@@ -291,6 +291,39 @@
+ 	free(value);
+ }
+ 
++static int glyph_compare(void* key1, void* key2, size_t key_size) {
++	glyph_hash_key_t* a = key1;
++	glyph_hash_key_t* b = key2;
++	return
++		a->font == b->font &&
++		a->size == b->size &&
++		a->ch == b->ch &&
++		a->bold == b->bold &&
++		a->italic == b->italic &&
++		a->scale_x == b->scale_x &&
++		a->scale_y == b->scale_y &&
++		a->advance.x == b->advance.x &&
++		a->advance.y == b->advance.y &&
++		a->outline == b->outline;
++}
++
++static unsigned glyph_hash(void* buf, size_t len)
++{
++	glyph_hash_key_t* g = buf;
++	unsigned hval = FNV1_32A_INIT;
++	hval = fnv_32a_buf(&g->font, sizeof(g->font), hval);
++	hval = fnv_32a_buf(&g->size, sizeof(g->size), hval);
++	hval = fnv_32a_buf(&g->ch, sizeof(g->ch), hval);
++	hval = fnv_32a_buf(&g->bold, sizeof(g->bold), hval);
++	hval = fnv_32a_buf(&g->italic, sizeof(g->italic), hval);
++	hval = fnv_32a_buf(&g->scale_x, sizeof(g->scale_x), hval);
++	hval = fnv_32a_buf(&g->scale_y, sizeof(g->scale_y), hval);
++	hval = fnv_32a_buf(&g->advance.x, sizeof(g->advance.x), hval);
++	hval = fnv_32a_buf(&g->advance.y, sizeof(g->advance.y), hval);
++	hval = fnv_32a_buf(&g->outline, sizeof(g->outline), hval);
++	return hval;
++}
++
+ void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
+ {
+ 	return hashmap_insert(glyph_cache, key, val);
+@@ -311,7 +344,9 @@
+ 	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
+ 				   sizeof(glyph_hash_val_t),
+ 				   0xFFFF + 13,
+-				   glyph_hash_dtor, NULL, NULL);
++				   glyph_hash_dtor,
++				   glyph_compare,
++				   glyph_hash);
+ }
+ 
+ void ass_glyph_cache_done(void)
+diff -urNad svn~/libmpcodecs/vf.c svn/libmpcodecs/vf.c
+--- svn~/libmpcodecs/vf.c	2008-10-19 09:17:10.000000000 +0200
++++ svn/libmpcodecs/vf.c	2008-10-19 09:42:21.000000000 +0200
+@@ -99,6 +99,7 @@
+ extern const vf_info_t vf_info_blackframe;
+ extern const vf_info_t vf_info_geq;
+ extern const vf_info_t vf_info_ow;
++extern const vf_info_t vf_info_fixpts;
+ 
+ // list of available filters:
+ static const vf_info_t* const filter_list[]={
+@@ -191,6 +192,7 @@
+     &vf_info_yadif,
+     &vf_info_blackframe,
+     &vf_info_ow,
++    &vf_info_fixpts,
+     NULL
+ };
+ 
+diff -urNad svn~/libmpcodecs/vf_fixpts.c svn/libmpcodecs/vf_fixpts.c
+--- svn~/libmpcodecs/vf_fixpts.c	1970-01-01 01:00:00.000000000 +0100
++++ svn/libmpcodecs/vf_fixpts.c	2008-10-19 09:42:21.000000000 +0200
+@@ -0,0 +1,137 @@
++/*
++    Copyright (C) 2007 Nicolas George <nicolas.george@normalesup.org>
++
++    This program is free software; you can redistribute it and/or modify
++    it under the terms of the GNU General Public License as published by
++    the Free Software Foundation; either version 2 of the License, or
++    (at your option) any later version.
++
++    This program is distributed in the hope that it will be useful,
++    but WITHOUT ANY WARRANTY; without even the implied warranty of
++    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++    GNU General Public License for more details.
++
++    You should have received a copy of the GNU General Public License
++    along with this program; if not, write to the Free Software
++    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
++*/
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <inttypes.h>
++
++#include "config.h"
++#include "mp_msg.h"
++#include "help_mp.h"
++
++#include "img_format.h"
++#include "mp_image.h"
++#include "vf.h"
++
++struct vf_priv_s {
++    double current;
++    double step;
++    int autostart;
++    int autostep;
++    unsigned have_step: 1;
++    unsigned print: 1;
++};
++
++static int put_image(vf_instance_t *vf, mp_image_t *src, double pts)
++{
++    struct vf_priv_s *p = vf->priv;
++
++    if(p->print) {
++	if(pts == MP_NOPTS_VALUE)
++	    printf("PTS: undef\n");
++	else
++	    printf("PTS: %f\n", pts);
++    }
++    if(pts != MP_NOPTS_VALUE && p->autostart != 0) {
++	p->current = pts;
++	if(p->autostart > 0)
++	    p->autostart--;
++    } else if(pts != MP_NOPTS_VALUE && p->autostep > 0) {
++	p->step = pts - p->current;
++	p->current = pts;
++	p->autostep--;
++	p->have_step = 1;
++    } else if(p->have_step) {
++	p->current += p->step;
++	pts = p->current;
++    } else {
++	pts = MP_NOPTS_VALUE;
++    }
++    return vf_next_put_image(vf, src, pts);
++}
++
++static void uninit(vf_instance_t *vf)
++{
++    free(vf->priv);
++}
++
++static int parse_args(struct vf_priv_s *p, const char *args)
++{
++    int pos;
++    double num, denom = 1;
++    int iarg;
++
++    while(*args != 0) {
++	pos = 0;
++	if(sscanf(args, "print%n", &pos) == 0 && pos > 0) {
++	    p->print = 1;
++	} else if(sscanf(args, "fps=%lf%n/%lf%n", &num, &pos, &denom, &pos) >= 1
++	    && pos > 0) {
++	    p->step = denom / num;
++	    p->have_step = 1;
++	} else if(sscanf(args, "start=%lf%n", &num, &pos) >= 1 && pos > 0) {
++	    p->current = num;
++	} else if(sscanf(args, "autostart=%d%n", &iarg, &pos) == 1 && pos > 0) {
++	    p->autostart = iarg;
++	} else if(sscanf(args, "autofps=%d%n", &iarg, &pos) == 1 && pos > 0) {
++	    p->autostep = iarg;
++	} else {
++	    mp_msg(MSGT_VFILTER, MSGL_FATAL,
++		"fixpts: unknown suboption: %s\n", args);
++	    return 0;
++	}
++	args += pos;
++	if(*args == ':')
++	    args++;
++    }
++    return 1;
++}
++
++static int open(vf_instance_t *vf, char *args)
++{
++    struct vf_priv_s *p;
++    struct vf_priv_s ptmp = {
++	.current = 0,
++	.step = 0,
++	.autostart = 0,
++	.autostep = 0,
++	.have_step = 0,
++	.print = 0,
++    };
++
++    if(!parse_args(&ptmp, args == NULL ? "" : args))
++	return 0;
++
++    vf->put_image = put_image;
++    vf->uninit = uninit;
++    vf->priv = p = malloc(sizeof(struct vf_priv_s));
++    *p = ptmp;
++    p->current = -p->step;
++
++    return 1;
++}
++
++vf_info_t vf_info_fixpts = {
++  "Fix presentation timestamps",
++  "fixpts",
++  "Nicolas George",
++  "",
++  &open,
++  NULL
++};
+diff -urNad svn~/mencoder.c svn/mencoder.c
+--- svn~/mencoder.c	2008-10-19 09:17:10.000000000 +0200
++++ svn/mencoder.c	2008-10-19 09:42:21.000000000 +0200
+@@ -198,6 +198,7 @@
+ 
+ int auto_expand=1;
+ int encode_duplicates=1;
++int keep_pts=0;
+ 
+ // infos are empty by default
+ char *info_name=NULL;
+@@ -361,6 +362,44 @@
+ 
+ static muxer_t* muxer=NULL;
+ 
++void add_subtitles(char *filename, float fps, int silent)
++{
++    sub_data *subd;
++#ifdef CONFIG_ASS
++    ass_track_t *asst = 0;
++#endif
++
++    if (filename == NULL) return;
++
++    subd = sub_read_file(filename, fps);
++#ifdef CONFIG_ASS
++    if (ass_enabled)
++#ifdef USE_ICONV
++        asst = ass_read_file(ass_library, filename, sub_cp);
++#else
++        asst = ass_read_file(ass_library, filename, 0);
++#endif
++    if (ass_enabled && subd && !asst)
++        asst = ass_read_subdata(ass_library, subd, fps);
++
++    if (!asst && !subd && !silent)
++#else
++    if(!subd && !silent) 
++#endif
++        mp_msg(MSGT_CPLAYER, MSGL_ERR, MSGTR_CantLoadSub,
++		filename_recode(filename));
++ 
++#ifdef CONFIG_ASS
++    if (!asst && !subd) return;
++    ass_track = asst;
++#else
++    if (!subd) return;
++#endif
++    mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_FILE_SUB_FILENAME=%s\n",
++	   filename_recode(filename));
++    subdata = subd;
++}
++
+ extern void print_wave_header(WAVEFORMATEX *h, int verbose_level);
+ 
+ int main(int argc,char* argv[]){
+@@ -562,6 +601,10 @@
+   m_entry_set_options(mconfig,&filelist[curfile]);
+   filename = filelist[curfile].name;
+  
++#ifdef CONFIG_ASS
++  ass_library = ass_init();
++#endif
++
+   if(!filename){
+ 	mp_msg(MSGT_CPLAYER, MSGL_FATAL, MSGTR_MissingFilename);
+ 	mencoder_exit(1,NULL);
+@@ -685,26 +728,6 @@
+     }
+   }
+ 
+-// after reading video params we should load subtitles because
+-// we know fps so now we can adjust subtitles time to ~6 seconds AST
+-// check .sub
+-//  current_module="read_subtitles_file";
+-  if(sub_name && sub_name[0]){
+-    subdata=sub_read_file(sub_name[0], sh_video->fps);
+-    if(!subdata) mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CantLoadSub,sub_name[0]);
+-  } else
+-  if(sub_auto && filename) { // auto load sub file ...
+-    char **tmp = NULL;
+-    int i = 0;
+-    char *psub = get_path( "sub/" );
+-    tmp = sub_filenames((psub ? psub : ""), filename);
+-    free(psub);
+-    subdata=sub_read_file(tmp[0], sh_video->fps);
+-    while (tmp[i])
+-      free(tmp[i++]);
+-    free(tmp);
+-  }
+-
+ // set up video encoder:
+ 
+ if (!curfile) { // curfile is non zero when a second file is opened
+@@ -885,12 +908,72 @@
+     ve = sh_video->vfilter;
+   } else sh_video->vfilter = ve;
+     // append 'expand' filter, it fixes stride problems and renders osd:
++#ifdef CONFIG_ASS
++    if (auto_expand && !ass_enabled) { /* we do not want both */
++#else
+     if (auto_expand) {
++#endif
+       char* vf_args[] = { "osd", "1", NULL };
+       sh_video->vfilter=vf_open_filter(sh_video->vfilter,"expand",vf_args);
+     }
++
++#ifdef CONFIG_ASS
++  if(ass_enabled) {
++    int i;
++    int insert = 1;
++    if (vf_settings)
++      for (i = 0; vf_settings[i].name; ++i)
++        if (strcmp(vf_settings[i].name, "ass") == 0) {
++          insert = 0;
++          break;
++        }
++    if (insert) {
++      extern vf_info_t vf_info_ass;
++      vf_info_t* libass_vfs[] = {&vf_info_ass, NULL};
++      char* vf_arg[] = {"auto", "1", NULL};
++      vf_instance_t* vf_ass = vf_open_plugin(libass_vfs,sh_video->vfilter,"ass",vf_arg);
++      if (vf_ass)
++        sh_video->vfilter=(void*)vf_ass;
++      else
++        mp_msg(MSGT_CPLAYER,MSGL_ERR, "ASS: cannot add video filter\n");
++    }
++    if (!keep_pts) {
++      keep_pts = 1;
++      mp_msg(MSGT_MENCODER, MSGL_WARN, "Warning: -ass implies -keep-pts, "
++	"which may cause \"badly interleaved\" files.\n");
++    }
++  }
++#endif
++
+     sh_video->vfilter=append_filters(sh_video->vfilter);
+ 
++#ifdef CONFIG_ASS
++  if (ass_enabled)
++    ((vf_instance_t *)sh_video->vfilter)->control(sh_video->vfilter, VFCTRL_INIT_EOSD, ass_library);
++#endif
++
++// after reading video params we should load subtitles because
++// we know fps so now we can adjust subtitles time to ~6 seconds AST
++// check .sub
++//  current_module="read_subtitles_file";
++  if(sub_name && sub_name[0]){
++    for (i = 0; sub_name[i] != NULL; ++i) 
++        add_subtitles (sub_name[i], sh_video->fps, 0); 
++  } else
++  if(sub_auto && filename) { // auto load sub file ...
++    char **tmp = NULL;
++    int i = 0;
++    char *psub = get_path( "sub/" );
++    tmp = sub_filenames((psub ? psub : ""), filename);
++    free(psub);
++    while (tmp[i])
++    {
++      add_subtitles (tmp[i], sh_video->fps, 0);
++      free(tmp[i++]);
++    }
++    free(tmp);
++  }
++
+     mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+     init_best_video_codec(sh_video,video_codec_list,video_fm_list);
+     mp_msg(MSGT_CPLAYER,MSGL_INFO,"==========================================================================\n");
+@@ -1346,7 +1429,8 @@
+     // decode_video will callback down to ve_*.c encoders, through the video filters
+     {void *decoded_frame = decode_video(sh_video,frame_data.start,frame_data.in_size,
+       skip_flag>0 && (!sh_video->vfilter || ((vf_instance_t *)sh_video->vfilter)->control(sh_video->vfilter, VFCTRL_SKIP_NEXT_FRAME, 0) != CONTROL_TRUE), MP_NOPTS_VALUE);
+-    blit_frame = decoded_frame && filter_video(sh_video, decoded_frame, MP_NOPTS_VALUE);}
++    blit_frame = decoded_frame && filter_video(sh_video, decoded_frame,
++	keep_pts ? sh_video->pts : MP_NOPTS_VALUE);}
+     
+     if (sh_video->vf_initialized < 0) mencoder_exit(1, NULL);
+     

Cambios de propiedades en debian-rvm/patches/04-ass_for_mencoder.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/patches/00list
===================================================================
--- debian-rvm/patches/00list	(revisión: 0)
+++ debian-rvm/patches/00list	(revisión: 0)
@@ -0,0 +1,4 @@
+03-runtime_eq.dpatch
+05-ass_for_mencoder_embeddedfonts.dpatch
+11-dshowserver.dpatch
+12-codecs.dpatch
Index: debian-rvm/patches/11-dshowserver.dpatch
===================================================================
--- debian-rvm/patches/11-dshowserver.dpatch	(revisión: 0)
+++ debian-rvm/patches/11-dshowserver.dpatch	(revisión: 0)
@@ -0,0 +1,324 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 11-dshowserver.dpatch by  <rvm@escomposlinux.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad mplayer-1.0~rc2svn28035~/Makefile mplayer-1.0~rc2svn28035/Makefile
+--- mplayer-1.0~rc2svn28035~/Makefile	2008-12-10 12:24:24.000000000 +0100
++++ mplayer-1.0~rc2svn28035/Makefile	2008-12-10 12:36:58.000000000 +0100
+@@ -20,6 +20,7 @@
+ # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ 
+ include config.mak
++EXTRALIBS += -lrt
+ 
+ 
+ ###### variable declarations #######
+@@ -518,6 +518,7 @@
+               stream/stream_mf.c \
+               stream/stream_null.c \
+               stream/url.c \
++              libmpcodecs/vd_dshowserver.c \
+               $(SRCS_COMMON-yes)
+ 
+ 
+diff -urNad mplayer-1.0~rc2svn28035~/libmpcodecs/vd.c mplayer-1.0~rc2svn28035/libmpcodecs/vd.c
+--- mplayer-1.0~rc2svn28035~/libmpcodecs/vd.c	2008-10-16 20:24:18.000000000 +0200
++++ mplayer-1.0~rc2svn28035/libmpcodecs/vd.c	2008-12-10 12:36:58.000000000 +0100
+@@ -29,6 +29,7 @@
+ extern vd_functions_t mpcodecs_vd_ffmpeg;
+ extern vd_functions_t mpcodecs_vd_theora;
+ extern vd_functions_t mpcodecs_vd_dshow;
++extern vd_functions_t mpcodecs_vd_dshowserver;
+ extern vd_functions_t mpcodecs_vd_dmo;
+ extern vd_functions_t mpcodecs_vd_vfw;
+ extern vd_functions_t mpcodecs_vd_vfwex;
+@@ -61,6 +62,7 @@
+ #ifdef CONFIG_OGGTHEORA
+ 	&mpcodecs_vd_theora,
+ #endif
++        &mpcodecs_vd_dshowserver,
+ #ifdef CONFIG_WIN32DLL
+         &mpcodecs_vd_dshow,
+         &mpcodecs_vd_dmo,
+diff -urNad mplayer-1.0~rc2svn28035~/libmpcodecs/vd_dshowserver.c mplayer-1.0~rc2svn28035/libmpcodecs/vd_dshowserver.c
+--- mplayer-1.0~rc2svn28035~/libmpcodecs/vd_dshowserver.c	1970-01-01 01:00:00.000000000 +0100
++++ mplayer-1.0~rc2svn28035/libmpcodecs/vd_dshowserver.c	2008-12-10 12:36:58.000000000 +0100
+@@ -0,0 +1,275 @@
++#include <stdio.h>
++#include <stdlib.h>
++#include <stdarg.h>
++#include <semaphore.h>
++#include <sys/mman.h>
++#include <pthread.h>
++
++#include <sys/types.h>
++#include <unistd.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++#include <time.h>
++#include <sys/wait.h>
++
++#include "config.h"
++
++#include "mp_msg.h"
++#include "help_mp.h"
++
++#include "vd_internal.h"
++
++struct vd_struct {
++  union {
++    uint32_t ret;
++    uint32_t cmd;
++  };
++  uint32_t buflen;
++  uint64_t pts;
++  uint32_t unused[8];
++} __attribute__((__packed__));
++
++enum {
++  VD_END = 1,
++  VD_DECODE = 2,
++  VD_SEEK = 3,
++  VD_HAS_BIH = 0x10000,
++  VD_VERSION_MASK = 0xFFFF,
++};
++
++#ifdef __APPLE__
++  void ALRMhandler(int sig) {
++  }
++  int sem_twait(sem_t *sem, int t) {
++    int ret;
++    alarm(t);
++    ret = sem_wait(sem);
++    printf("twait complete\n");
++    return ret;
++  }
++  void init_twait() {
++    sigset_t none;
++    struct sigaction sa;
++    sigemptyset(&none);
++    sigprocmask(SIG_SETMASK, &none, 0);
++
++    sa.sa_handler = ALRMhandler;
++    sa.sa_flags = 0;
++    sigemptyset(&sa.sa_mask);
++    sigaction(SIGALRM, &sa, 0);
++  }
++#else
++  int sem_twait(sem_t *sem, int t) {
++    struct timespec ts;
++    clock_gettime(CLOCK_REALTIME, &ts);
++    ts.tv_sec += t;
++    return(sem_timedwait(sem, &ts));
++  }
++  void init_twait() {}
++#endif
++
++static vd_info_t info = {
++	"DirectShowServer video codecs",
++	"dshowserver",
++	"Alan Nisota",
++	"based on dshow",
++	"win32 codecs"
++};
++
++LIBVD_EXTERN(dshowserver)
++typedef struct {
++    int fd;
++    void *mem;
++    char *data;
++    char *picture;
++    int picsize;
++    int pagesize;
++    sem_t *sem_rd;
++    sem_t *sem_wr;
++    struct vd_struct *vd;
++} ds_mpi_t;
++static ds_mpi_t *ds_mpi;
++
++// to set/get/query special features/parameters
++static int control(sh_video_t *sh __attribute((unused)),int cmd,void* arg __attribute((unused)),...){
++    switch(cmd){
++    case VDCTRL_RESYNC_STREAM:
++      printf("Seek now\n");
++      ds_mpi->vd->cmd = VD_SEEK; //'3' is cmd for seek
++      sem_post(ds_mpi->sem_wr);
++      sem_twait(ds_mpi->sem_rd, 10);
++      return CONTROL_TRUE;
++    case VDCTRL_QUERY_MAX_PP_LEVEL:
++	return 4;
++    case VDCTRL_QUERY_UNSEEN_FRAMES:
++	return 10;
++
++    }
++    return CONTROL_UNKNOWN;
++}
++
++static int my_system(const char *command)
++{
++    pid_t child = fork();
++
++    if (child < 0)
++    {
++        /* Fork failed */
++        return child;
++    }
++    else if (child == 0)
++    {
++        /* Child */
++        int i;
++        /* Close all open file descriptors except stdout/stderr */
++        for (i = sysconf(_SC_OPEN_MAX) - 1; i > 2; i--)
++            close(i);
++
++        /* Attach stdin to /dev/null */
++        /*
++        close(0);
++        int fd = open("/dev/null", O_RDONLY);
++        dup2(fd, 0);
++        if (fd != 0)
++            close(fd);
++        */
++        /* Run command */
++        execl("/bin/sh", "sh", "-c", command, NULL);
++        _exit(0);
++    }
++    else
++    {
++        /* Parent */
++        int status;
++
++        waitpid(child, &status, 0);
++        return status;
++    }
++
++    return 1;
++}
++    
++// init driver
++static int init(sh_video_t *sh){
++    int ret;
++    char cmd[255], shm[80], sem1[80], sem2[80];
++    uint32_t out_fmt;
++    int bpp, w, h;
++    int extra = 0;
++    int numpages = 10;
++    int memsize;
++
++    init_twait();
++    out_fmt = sh->codec->outfmt[sh->outfmtidx];
++    switch(out_fmt){
++      case IMGFMT_YUY2:
++      case IMGFMT_UYVY:
++	bpp = 16; break;
++      case IMGFMT_YV12:
++      case IMGFMT_I420:
++      case IMGFMT_IYUV:
++	bpp = 12; break;
++      case IMGFMT_YVU9:
++        bpp = 9; break;
++      default:
++        bpp = 24; break;
++    }
++    w = sh->disp_w; h = sh->disp_h;
++    snprintf(cmd, 255, "dshowserver -c %s -s %dx%d "
++             "-g %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x "
++             "-f 0x%08x -b %d -o 0x%08x -p %d -i %x -n %d %s&",
++             sh->codec->dll, w, h,
++             (unsigned int)sh->codec->guid.f1, sh->codec->guid.f2, sh->codec->guid.f3,
++             sh->codec->guid.f4[0], sh->codec->guid.f4[1], sh->codec->guid.f4[2], sh->codec->guid.f4[3],
++             sh->codec->guid.f4[4], sh->codec->guid.f4[5], sh->codec->guid.f4[6], sh->codec->guid.f4[7],
++             (unsigned int)sh->format, bpp, out_fmt, getpid(), *(int *)pthread_self(), numpages, "");
++    snprintf(shm, 80, "/dshow_shm.%x", *(int *)pthread_self());
++    snprintf(sem1, 80, "/dshow_sem1.%x", *(int *)pthread_self());
++    snprintf(sem2, 80, "/dshow_sem2.%x", *(int *)pthread_self());
++    ds_mpi = (ds_mpi_t *) malloc(sizeof(ds_mpi_t));
++    ds_mpi->fd = shm_open(shm, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
++    ds_mpi->picsize =  w * h * bpp / 8;
++    ds_mpi->pagesize = ds_mpi->picsize + 1024;
++    memsize = sizeof(struct vd_struct) + w * h + ds_mpi->picsize + extra + ds_mpi->pagesize * numpages;
++    ftruncate(ds_mpi->fd, memsize);
++    ds_mpi->mem = mmap(NULL, memsize, PROT_READ | PROT_WRITE, MAP_SHARED, ds_mpi->fd, 0);
++    if(ds_mpi->mem == MAP_FAILED) {
++      perror("mmap");
++      return 0;
++    }
++    memset((char *)ds_mpi->mem, 0, sizeof(struct vd_struct));
++    if (extra)
++      memset((char *)ds_mpi->mem + (memsize - extra), 0, extra);
++    ds_mpi->vd = (struct vd_struct *)ds_mpi->mem;
++    ds_mpi->data = ((char *)ds_mpi->mem) + sizeof(struct vd_struct);
++    ds_mpi->picture = ds_mpi->data + w * h;
++    if(sh->bih->biWidth && sh->bih->biHeight) {
++      ds_mpi->vd->cmd |= VD_HAS_BIH; //Use embedded bih
++      memcpy(ds_mpi->data, sh->bih, sh->bih->biSize);
++    }
++    //Create read/write semaphores in locked state
++    ds_mpi->sem_wr = sem_open(sem1, O_CREAT, 0644, 0);
++    ds_mpi->sem_rd = sem_open(sem2, O_CREAT, 0644, 0);
++    my_system(cmd);
++    ret = sem_twait(ds_mpi->sem_rd, 10);
++    shm_unlink(shm);
++    sem_unlink(sem1);
++    sem_unlink(sem2);
++    if(ret != 0) {
++      printf("DirectShow filter failed");
++      return 0;
++    } else {
++      if(!mpcodecs_config_vo(sh,w,h,IMGFMT_YUY2)) return 0;
++      printf("Found DirectShow filter");
++      return 1;
++    }
++}
++
++// uninit driver
++static void uninit(sh_video_t *sh __attribute((unused))){
++    if(ds_mpi) {
++      printf("Destroying filter");
++      ds_mpi->vd->cmd = VD_END; //'1' is cmd for terminating
++      sem_post(ds_mpi->sem_wr);
++      close(ds_mpi->fd);
++      sem_close(ds_mpi->sem_wr);
++      sem_close(ds_mpi->sem_rd);
++      free(ds_mpi);
++      ds_mpi = NULL;
++    }
++}
++
++//mp_image_t* mpcodecs_get_image(sh_video_t *sh, int mp_imgtype, int mp_imgflag, int w, int h);
++
++// decode a frame
++static mp_image_t* decode(sh_video_t *sh,void* data,int len,int flags){
++   mp_image_t* mpi = NULL;
++   int ret;
++   if(len<=0) return NULL; // skipped frame
++    
++   if(flags&3) {
++      // framedrop:
++      return NULL;
++   }
++   ds_mpi->vd->cmd = VD_DECODE; //'2' is cmd for decoding
++   ds_mpi->vd->pts = (uint64_t)(sh->buffered_pts[0]*1E9);
++   memcpy(ds_mpi->data, data, len);
++   ds_mpi->vd->buflen = len;
++   sem_post(ds_mpi->sem_wr);
++   ret = sem_twait(ds_mpi->sem_rd, 10);
++   //printf("PTS (%d): %f -> %f\n", ds_mpi->vd->ret, sh->buffered_pts[0], (double)ds_mpi->vd->pts/1E9);
++   //printf("PTS (%d): %f(%d) -> %d\n", ds_mpi->vd->ret, sh->buffered_pts[0], pts-1, ds_mpi->vd->pts);
++   if(ret == 0 && ds_mpi->vd->ret && ! (ds_mpi->vd->ret & (1<<31))) {
++     if(ds_mpi->vd->pts)
++       sh->buffered_pts[0] = (double)ds_mpi->vd->pts/1E9;
++     mpi=mpcodecs_get_image(sh, MP_IMGTYPE_TEMP, 0 /*MP_IMGFLAG_ACCEPT_STRIDE*/, 
++                            sh->disp_w, sh->disp_h);
++     if(ds_mpi->vd->ret & 0x02) {
++       unsigned char page = ds_mpi->vd->ret >> 8;
++       memcpy(mpi->planes[0], ds_mpi->picture + ds_mpi->picsize + page * ds_mpi->pagesize, ds_mpi->picsize);
++     } else {
++       memcpy(mpi->planes[0], ds_mpi->picture, ds_mpi->picsize);
++     }
++   }
++   return mpi;
++}

Cambios de propiedades en debian-rvm/patches/11-dshowserver.dpatch
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/copyright
===================================================================
--- debian-rvm/copyright	(revisión: 0)
+++ debian-rvm/copyright	(revisión: 0)
@@ -0,0 +1,28 @@
+This package was debianized by Sebastian Dröge <slomo@ubuntu.com>
+Thu, 01 Dec 2005 20:40:19 +0100.
+
+It was downloaded from http://www.mplayerhq.hu
+
+Copyright Holders:
+ MPlayer is copyrighted by various authors.
+ They are all listed in the 'Copyright' file
+
+License:
+
+ mplayer is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of the
+ License, or (at your option) any later version.
+
+ mplayer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+
+On Debian systems, the complete text of the GNU General
+Public License can be found in `/usr/share/common-licenses/GPL'.
+
Index: debian-rvm/rules
===================================================================
--- debian-rvm/rules	(revisión: 0)
+++ debian-rvm/rules	(revisión: 0)
@@ -0,0 +1,156 @@
+#!/usr/bin/make -f
+#-*- makefile -*-
+
+#export DH_VERBOSE=1
+
+include /usr/share/dpatch/dpatch.make
+
+unexport CFLAGS
+
+DEB_BUILD_ARCH ?= $(shell dpkg-architecture -qDEB_BUILD_ARCH)
+
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+	INSTALL_PROGRAM += -s
+endif
+
+ifeq "$(DEB_BUILD_ARCH)" "i386"
+	CONFIGURE_ARCH = --enable-runtime-cpudetection --target=i586-linux
+else
+ifeq "$(DEB_BUILD_ARCH)" "powerpc"
+	CONFIGURE_ARCH = --enable-runtime-cpudetection --enable-altivec
+else
+ifeq "$(DEB_BUILD_ARCH)" "amd64"
+	CONFIGURE_ARCH = --enable-runtime-cpudetection
+endif
+endif
+endif
+
+CONFIGURE_PATH := --prefix=/usr --confdir=/etc/mplayer --mandir=/usr/share/man --win32codecsdir=/usr/lib/win32
+#CONFIGURE_COMMON := --enable-largefiles
+#CONFIGURE_INPUT :=  --disable-dvdread-internal 
+CONFIGURE_INPUT :=  --disable-libdvdcss-internal
+#CONFIGURE_CONTROL := --enable-lirc --enable-joystick --enable-xf86keysym 
+#CONFIGURE_AUDIO_CODECS := --disable-tremor-internal --enable-liba52 --enable-musepack --enable-speex --enable-libvorbis --enable-mad --enable-mp3lib
+#CONFIGURE_VIDEO_CODECS := --enable-theora --enable-libdv --enable-libmpeg2 --enable-tv-v4l2
+#CONFIGURE_AUDIO_OUT := --enable-alsa --enable-ossaudio --enable-esd --enable-arts --enable-pulse --enable-nas
+CONFIGURE_VIDEO_OUT := --enable-xvmc --enable-menu
+#CONFIGURE_MISC := --enable-freetype --enable-gif --enable-png --enable-jpeg --enable-liblzo --enable-fribidi --enable-ladspa
+
+CONFIGURE_ALL := $(CONFIGURE_ARCH) $(CONFIGURE_PATH) $(CONFIGURE_COMMON) $(CONFIGURE_INPUT) $(CONFIGURE_CONTROL) $(CONFIGURE_AUDIO_CODECS) $(CONFIGURE_VIDEO_CODECS) $(CONFIGURE_AUDIO_OUT) $(CONFIGURE_VIDEO_OUT) $(CONFIGURE_MISC)
+
+build-gui: build-gui-stamp
+build-gui-stamp: patch 
+	dh_testdir
+	./configure $(CONFIGURE_ALL) --enable-gui --enable-mencoder
+	$(MAKE)
+
+# Documentation
+	cd DOCS/xml && ./configure && make html-chunked
+
+	touch build-gui-stamp
+
+#build-nogui: build-nogui-stamp
+#build-nogui-stamp:
+#	dh_testdir
+#	if test -f build-gui-stamp; then \
+#	  $(MAKE) distclean; \
+#	  rm -f build-gui-stamp; \
+#	fi
+#	./configure $(CONFIGURE_ALL) --disable-gui --disable-mencoder
+#	$(MAKE) -f debian/rules modify-config
+#	$(MAKE)
+#	touch build-nogui-stamp
+
+install:
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	$(MAKE) -f debian/rules install-gui
+#	$(MAKE) -f debian/rules install-nogui
+
+install-gui: build-gui
+	dh_installdirs -pmplayer
+	$(MAKE) install DESTDIR=$(CURDIR)/debian/mplayer
+	
+	dh_link -pmplayer usr/bin/mplayer usr/bin/gmplayer
+	dh_link -pmplayer usr/share/man/man1/mplayer.1.gz usr/share/man/man1/gmplayer.1.gz
+	dh_link -pmplayer usr/share/fonts/truetype/ttf-dejavu/DejaVuSans.ttf usr/share/mplayer/subfont.ttf
+#	cp etc/example.conf etc/mplayer.conf
+	cp debian/mplayer.conf debian/mplayer/etc/mplayer/
+#	dh_install -pmplayer etc/mplayer.conf etc/mplayer
+#	rm -f etc/mplayer.conf
+	dh_install -pmplayer etc/input.conf etc/mplayer
+	dh_install -pmplayer etc/menu.conf etc/mplayer
+	dh_installexamples -pmplayer -X.svn -X.libdeps etc
+	dh_install -pmplayer
+
+	#remove mencoder manpage link to prevent conflict with the mencoder package
+	rm debian/mplayer/usr/share/man/man1/mencoder.1
+
+	#split off mencoder package
+	mkdir -p debian/mencoder/usr/bin
+	mv debian/mplayer/usr/bin/mencoder debian/mencoder/usr/bin
+	mkdir -p debian/mencoder/usr/share/man/man1
+	cp debian/mplayer/usr/share/man/man1/mplayer.1 debian/mencoder/usr/share/man/man1/mencoder.1
+
+#install-nogui: build-nogui
+#	dh_installdirs -pmplayer-nogui
+#	$(MAKE) install DESTDIR=$(CURDIR)/debian/mplayer-nogui
+#	dh_link -pmplayer-nogui usr/share/fonts/truetype/ttf-dejavu/DejaVuSans.ttf usr/share/mplayer/subfont.ttf
+#	cp etc/example.conf etc/mplayer.conf
+#	dh_install -pmplayer-nogui etc/mplayer.conf etc/mplayer
+#	rm -f etc/mplayer.conf
+#	dh_install -pmplayer-nogui etc/input.conf etc/mplayer
+#	dh_install -pmplayer-nogui etc/menu.conf etc/mplayer
+#	dh_installexamples -pmplayer-nogui -X.libdeps etc
+#	dh_install -pmplayer-nogui
+
+clean: unpatch
+	dh_testdir
+	dh_testroot
+	-cd DOCS/xml && $(MAKE) distclean
+	-$(MAKE) distclean
+	-rm -f build-nogui-stamp build-gui-stamp
+	# additional cleanups
+	#-rm config.mak version.h libaf/config.mak libao2/config.mak libvo/config.mak Gui/config.mak
+	dh_clean
+
+binary-indep: build install
+	dh_testdir
+	dh_testroot
+	dh_installdocs -pmplayer-doc -X.svn Copyright DOCS/HTML DOCS/tech
+	dh_installchangelogs -i
+	dh_compress -i
+	dh_link -i
+	dh_fixperms -i
+	dh_strip -i
+	dh_installdeb -i
+	dh_gencontrol -i
+	dh_md5sums -i
+#	dh_builddeb -- -Z lzma
+	dh_builddeb -i
+
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_install -a
+	dh_installdocs -a -A Copyright
+	dh_installmenu -a
+	dh_installmime -a
+	dh_installman -a
+	dh_installchangelogs -a Changelog
+	dh_desktop -a
+	dh_compress -a
+	dh_link -a
+	dh_fixperms -a
+	dh_strip -a
+	dh_perl -a
+	dh_installdeb -a
+	dh_shlibdeps -a
+	dh_gencontrol -a
+	dh_md5sums -a
+#	dh_builddeb -- -Z lzma
+	dh_builddeb -a
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary

Cambios de propiedades en debian-rvm/rules
___________________________________________________________________
Nombre: svn:executable
   + *

Index: debian-rvm/mplayer-nogui.preinst
===================================================================
--- debian-rvm/mplayer-nogui.preinst	(revisión: 0)
+++ debian-rvm/mplayer-nogui.preinst	(revisión: 0)
@@ -0,0 +1,40 @@
+#!/bin/sh
+
+set -e
+
+# Remove a no-longer used conffile
+rm_conffile() {
+    CONFFILE="$1"
+
+    if [ -e "$CONFFILE" ]; then
+        md5sum="`md5sum \"$CONFFILE\" | sed -e \"s/ .*//\"`"
+	old_md5sum="`sed -n -e \"/^Conffiles:/,/^[^ ]/{\\\\' $CONFFILE '{s/ obsolete$//;s/.* //;p}}\" /var/lib/dpkg/status`"
+        if [ "$md5sum" != "$old_md5sum" ]; then
+            echo "Obsolete conffile $CONFFILE has been modified by you."
+            echo "Saving as $CONFFILE.dpkg-bak ..."
+            mv -f "$CONFFILE" "$CONFFILE".dpkg-bak
+        else
+            echo "Removing obsolete conffile $CONFFILE ..."
+            rm -f "$CONFFILE"
+        fi
+    fi
+}
+
+case "$1" in
+    install|upgrade)
+        if dpkg --compare-versions "$2" le "2:0.99+1.0pre8-0ubuntu5"; then
+            rm_conffile "/etc/mplayer/codecs.conf"
+        fi
+    ;;
+
+    abort-upgrade)
+    ;;
+
+    *)
+        echo "preinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+#DEBHELPER#
+
Index: debian-rvm/mplayer.preinst
===================================================================
--- debian-rvm/mplayer.preinst	(revisión: 0)
+++ debian-rvm/mplayer.preinst	(revisión: 0)
@@ -0,0 +1,40 @@
+#!/bin/sh
+
+set -e
+
+# Remove a no-longer used conffile
+rm_conffile() {
+    CONFFILE="$1"
+
+    if [ -e "$CONFFILE" ]; then
+        md5sum="`md5sum \"$CONFFILE\" | sed -e \"s/ .*//\"`"
+	old_md5sum="`sed -n -e \"/^Conffiles:/,/^[^ ]/{\\\\' $CONFFILE '{s/ obsolete$//;s/.* //;p}}\" /var/lib/dpkg/status`"
+        if [ "$md5sum" != "$old_md5sum" ]; then
+            echo "Obsolete conffile $CONFFILE has been modified by you."
+            echo "Saving as $CONFFILE.dpkg-bak ..."
+            mv -f "$CONFFILE" "$CONFFILE".dpkg-bak
+        else
+            echo "Removing obsolete conffile $CONFFILE ..."
+            rm -f "$CONFFILE"
+        fi
+    fi
+}
+
+case "$1" in
+    install|upgrade)
+        if dpkg --compare-versions "$2" le "2:0.99+1.0pre8-0ubuntu5"; then
+            rm_conffile "/etc/mplayer/codecs.conf"
+        fi
+    ;;
+
+    abort-upgrade)
+    ;;
+
+    *)
+        echo "preinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+#DEBHELPER#
+
Index: debian-rvm/README
===================================================================
--- debian-rvm/README	(revisión: 0)
+++ debian-rvm/README	(revisión: 0)
@@ -0,0 +1,16 @@
+Source managment of ubuntu package
+
+Short: go here:
+
+https://launchpad.net/products/mplayer/+branches
+
+In the past we used dpatch to handle the mplayer package.
+nowadays, we handle the ubuntu package in bzr. Have a look
+at https://launchpad.net/products/mplayer/+branches to see 
+the different branches, into which the former dpatches
+where included.
+
+Please be careful when you update to 'upstream' branch. 
+Use the 'get-orig-source' target to clean the upstream tarballs.
+
+use bzr export to generate new orig.tar.gz
Index: debian-rvm/mplayer.conf
===================================================================
--- debian-rvm/mplayer.conf	(revisión: 0)
+++ debian-rvm/mplayer.conf	(revisión: 0)
@@ -0,0 +1,138 @@
+#
+# MPlayer configuration file
+#
+# Configuration files are read system-wide from /usr/local/etc/mplayer.conf
+# and per user from ~/.mplayer/config, where per-user settings override
+# system-wide settings, all of which are overrriden by the command line.
+#
+# The configuration file settings are the same as the command line
+# options without the preceding '-'.
+#
+# See the CONFIGURATION FILES section in the man page
+# for a detailed description of the syntax.
+
+
+##################
+# video settings #
+##################
+
+# Specify default video driver (see -vo help for a list).
+vo=xv,
+
+# Use SDL video with the aalib subdriver by default.
+#vo = sdl:aalib
+
+# FBdev driver:
+#
+# mode to use (read from fb.modes)
+#fbmode = 640x480-120
+#
+# location of the fb.modes file
+#fbmodeconfig = /etc/fb.modes
+
+# Specify your monitor timings for the vesa and fbdev video output drivers.
+# See /etc/X11/XF86Config for timings. Be careful; if you specify settings
+# that exceed the capabilities of your monitor, you may damage it.
+#
+# horizontal frequency range (k stands for 1000)
+#monitor-hfreq = 31.5k-50k,70k
+#
+# vertical frequency range
+#monitor-vfreq = 50-90
+#
+# dotclock (or pixelclock) range (m stands for 1000000)
+#monitor-dotclock = 30M-300M
+
+# Start in fullscreen mode by default.
+#fs=yes
+
+# Change to a different videomode when going fullscreen.
+#vm=yes
+
+# Override the autodetected color depth, may need 'vm=yes' as well.
+#bpp=0
+
+# Enable software scaling (powerful CPU needed) for video output
+# drivers that do not support hardware scaling.
+#zoom=yes
+
+# standard monitor size, with square pixels
+#monitoraspect=4:3
+
+# Use this for a widescreen monitor, non-square pixels.
+#monitoraspect=16:9
+
+# Keep the player window on top of all other windows.
+#ontop=yes
+
+
+##################
+# audio settings #
+##################
+
+# Specify default audio driver (see -ao help for a list).
+#ao=alsa,
+
+# Use SDL audio driver with the esd subdriver by default.
+#ao = sdl:esd
+
+# Specify the mixer device.
+#mixer = /dev/mixer
+
+# Resample the sound to 44100Hz with the lavcresample audio filter.
+#af=lavcresample=44100
+
+
+##################
+# other settings #
+##################
+
+# Default font
+#font=/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf
+
+# Font size
+#subfont-text-scale=3
+#subfont-osd-scale=3
+
+# Pretend to be Window Media Player.
+# Fixes playback when playlist and media file use the same URL.
+#user-agent=NSPlayer/4.1.0.3856
+
+# Drop frames to preserve audio/video sync.
+#framedrop = yes
+
+# Specify your preferred skin here (skins are searched for in
+# /usr/local/share/mplayer/skins/<name> and ~/.mplayer/skins/<name>).
+#skin = Abyss
+
+# Resample the font alphamap.
+# 0     plain white fonts
+# 0.75  very narrow black outline (default)
+# 1     narrow black outline
+# 10    bold black outline
+#ffactor = 0.75
+
+# cache settings
+#
+# Use 8MB input cache by default.
+#cache = 8192
+#
+# Prefill 20% of the cache before starting playback.
+#cache-min = 20.0
+#
+# Prefill 50% of the cache before restarting playback after the cache emptied.
+#cache-seek-min = 50
+
+# DVD: Display English subtitles if available.
+#slang = en
+
+# DVD: Play English audio tracks if available.
+#alang = en
+
+###################
+# DVDNAV Settings #
+###################
+#vc=ffmpeg12,
+
+# You can also include other configuration files.
+#include = /path/to/the/file/you/want/to/include
